#!/usr/bin/env bash
# git-get-file-specificity
# Given a file path, echo one of: common, specific, mixed (or nothing).
# Searches .git/file_specificity/{common,specific,mixed}

file="$1"
base=".git/file_specificity"

# Read a patterns file, strip comments/blanks
_read_patterns() {
  sed -e 's/#.*//' -e '/^[[:space:]]*$/d' "$1"
}

# 1) Check common & specific
for type in common specific; do
  while IFS= read -r pat; do
    if [[ "$pat" == */ ]]; then
      # directory prefix
      [[ "$file" == "${pat}"* ]] && echo "$type" && exit 0
    else
      # exact or glob
      if [[ "$file" == $pat ]]; then
        echo "$type"
        exit 0
      fi
    fi
  done < <(_read_patterns "$base/$type")
done

# 2) Check mixed: lines of "path [<whitespace> /regex/flags]"
while IFS= read -r line; do
  # strip out comments & blanks (already done upstream)
  # split into path and optional rawregex
  path=${line%%[[:space:]]*}
  rest=${line#"$path"}
  rawregex=$(echo "$rest" | awk '{print $1}')
  [[ -z "$path" ]] && continue

  # does the path prefix or exact match?
  match=false
  if [[ "$path" == */ ]]; then
    [[ "$file" == "${path}"* ]] && match=true
  else
    [[ "$file" == $path ]] && match=true
  fi

  if ! $match; then
    continue
  fi

  # if there's no regex, it's mixed
  if [[ -z "$rawregex" ]]; then
    echo mixed
    exit 0
  fi

  # parse /pattern/flags
  # remove leading slash, then split at last slash
  inner=${rawregex#"/"}     # drop leading /
  patt=${inner%/*}          # up to last slash
  flags=${inner##*/}        # after last slash

  # build grep options
  grep_opts="-E"
  [[ $flags == *i* ]] && grep_opts="$grep_opts -i"

  # test the file *path* against the pattern
  if echo "$file" | grep $grep_opts -q -- "$patt"; then
    echo mixed
    exit 0
  fi
done < <(_read_patterns "$base/mixed")

# no recorded classification
exit 0

