#!/usr/bin/env bash
# git-get-file-specificity
# Efficient version: loads each pattern file into its own Bash array; uses builtins for matching.
# Debug output to stderr; disable by unsetting DEBUG.

file="$1"
base=".git/file_specificity"

# load patterns into separate arrays
common_pats=()
specific_pats=()
mixed_pats=()
for type in common specific mixed; do
  patfile="$base/$type"
  [[ ! -f "$patfile" ]] && continue
  # read, strip comments & blanks
  while IFS= read -r line; do
    pat="\$(echo "$line" | sed -e 's/#.*//' -e 's/[[:space:]]*$//')"
    [[ -z "$pat" ]] && continue
    case "$type" in
      common) common_pats+=("$pat") ;; 
      specific) specific_pats+=("$pat") ;; 
      mixed) mixed_pats+=("$pat") ;; 
    esac
  done < "$patfile"
done

matches=()
for type in common specific mixed; do
  # select correct array
  declare -n pats="${type}_pats"
  [[ \${#pats[@]} -eq 0 ]] && continue
  [[ -n "$DEBUG" ]] && echo "[DEBUG] checking $type (\${#pats[@]} patterns)" >&2

  for pat in "\${pats[@]}"; do
    if [[ "$pat" == */ ]]; then
      [[ -n "$DEBUG" ]] && echo "[DEBUG] prefix: '$file' starts with '$pat'" >&2
      if [[ "$file" == ${pat}* ]]; then
        matches+=("$type")
        break
      fi
    else
      [[ -n "$DEBUG" ]] && echo "[DEBUG] glob: '$file' == '$pat'" >&2
      if [[ "$file" == $pat ]]; then
        matches+=("$type")
        break
      fi
    fi
  done
done

# decide based on how many matches
case \${#matches[@]} in
  0)
    # nothing recorded
    exit 0
    ;;
  1)
    echo "\${matches[0]}"
    exit 0
    ;;
  *)
    echo "ERROR: '$file' matches multiple lists: \${matches[*]}" >&2
    exit 1
    ;;
esac

