#!/usr/bin/env bash
# git-get-file-specificity
# Efficient version: loads patterns into arrays once, uses bash builtins for matching.
# Debug output to stderr; disable by unsetting DEBUG.

file="$1"
base=".git/file_specificity"
DEBUG=1

# load patterns into associative array of arrays
declare -A pats
for type in common specific mixed; do
  patfile="$base/$type"
  [[ ! -f "$patfile" ]] && continue
  # read, strip comments & blanks
  mapfile -t arr < <(sed -e 's/#.*//' -e 's/[[:space:]]*$//' -e '/^[[:space:]]*$/d' "$patfile")
  pats[$type]="${arr[*]}"
done

matches=()
for type in common specific mixed; do
  # retrieve patterns
  IFS=$'\n' read -r -d '' -a patterns < <(printf "%s\0" "${pats[$type]}")
  echo "$type: ${patterns[0]}"
  [[ ${#patterns[@]} -eq 0 ]] && continue
  [[ -n "$DEBUG" ]] && echo "[DEBUG] checking $type (${#patterns[@]} patterns)" >&2

  for pat in "${patterns[@]}"; do
    [[ -z "$pat" ]] && continue
    if [[ "$pat" == */ ]]; then
      [[ -n "$DEBUG" ]] && echo "[DEBUG] prefix: '$file' starts with '$pat'" >&2
      if [[ "$file" == ${pat}* ]]; then
        matches+=("$type")
        break
      fi
    else
      [[ -n "$DEBUG" ]] && echo "[DEBUG] glob: '$file' == '$pat'" >&2
      if [[ "$file" == $pat ]]; then
        matches+=("$type")
        break
      fi
    fi
  done
done

echo ${matches[@]}
# output decision
case ${#matches[@]} in
  0)
    exit 0
    ;;
  1)
    echo "${matches[0]}"
    exit 0
    ;;
  *)
    echo "ERROR: '$file' matches multiple lists: ${matches[*]}" >&2
    exit 1
    ;;
esac

