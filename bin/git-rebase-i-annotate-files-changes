#!/bin/bash
set -e

# See notes in git-rebase-i-annotate-files-changes.txt

mkdir -p .git/.local
commit_list_file=.git/.local/rebase_annotated_commit_list

if [ -z "$1" ]; then
  echo >&2 "Usage: $(basename $0) <onto_commit>"
  echo >&2 "Rebases onto <onto_commit>."
  echo >&2 "Generates a file, $commit_list_file, containing the list of commits that will be applied onto <onto_commit> along with information that will be helpful in determining which commits can be safely reordered without any chance of a merge conflict."
  exit 1
fi

onto=$1; shift

cd $(dirname "$(git rev-parse --git-dir)")
[ -e $commit_list_file ] && ls -lA $commit_list_file

# --noninteractive
orig_base=$(git-ensure-commit-is-ancestor $onto 2>/dev/null)
git log-oneline --reverse $orig_base..@ > .git/.local/commits_from_orig_base
# For a one-line-formatted list of commits from original base that you can compare against
echo "Do vertical split with .git/.local/commits_from_orig_base if you want to compare original list of commits with new list (to make sure you haven't included a duplicate commit, for example, if you are rebasing on a new base with many similar + diverging commits)

git log --reverse --no-color --name-status --pretty=format:"______________________________________%n%h  (%ai)%n%s%b"  $onto^...@ > $(
  file=.git/.local/$(now)_rebase_annotated_commit_list
  symlink -f $file $commit_list_file
  echo_to_both $file
)

git-commit-fixup-rebase  $onto
#git commit --fixup $onto
#git rebase -i --autosquash $onto^

