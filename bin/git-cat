#!/usr/bin/ruby

def usage
  puts <<End
Usage: #{File.basename($0)} [options*] <path>
   or: #{File.basename($0)} [options*] <commit>:<path>

Options:
  --save, -s
  --name-only, -n            -- Save as <path>. Do not add <commit> to filename. (Useful only when <commit> is specified)
  --overwrite, -f            -- Save even if output file already exists. Implies --save.
  -O<file> --save-as=<file>  -- Save to <file>. Implies --save.

Cat/show a file from a certain rev (HEAD assumed if none supplied)

Basically the same as git-show, with these exceptions:
* Unlike git-show, you CAN pass a relative path (if you're in a subdirectory, f.e.) and it will be automatically converted into the corresponding absolute path
* git-show doesn't have the --save option or related options

Keep in mind that it will page results, so long lines won't be wrapped. If you need long lines to be wrapped (so you can select the output with your mouse and know that you're not going to be getting any truncated lines, you many want to pipe to cat - or
Use git --no-pager show ...
End
  exit 1
end

require 'pathname'

#---------------------------------------------------------------------------------------------------
require 'getoptlong'
opts = GetoptLong.new(
    [ '--save-as', '--save-to', '-O', '--output-document', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--save', '-s',               GetoptLong::NO_ARGUMENT ],
    [ '--name-only', '-n',          GetoptLong::NO_ARGUMENT ],
    [ '--overwrite', '-f',          GetoptLong::NO_ARGUMENT ],
    [ '--quiet', '-q',              GetoptLong::NO_ARGUMENT ]
)
opts.each do | opt, arg |
  case opt
  when '--save-as', '--save-to', '-O', '--output-document'
    @save = true
    @save_as = arg
  when '--save', '-s'
    @save = true
  when '--name-only', '-n'
    @name_only = true
  when '--overwrite', '-f'
    @save = true
    @overwrite = true
  when '--quiet', '-q'
    @quiet = true
  end
end

if ARGV.size < 1
  usage; exit 1
end

if ARGV[0] =~ /([^:]+):(.*)/
  revision = $1
  path = $2
else
  revision = 'HEAD'
  path = ARGV[0]
end

#---------------------------------------------------------------------------------------------------

path_for_git_show = `git absolute-path #{path} 2>/dev/null`.chomp
if !$?.success?
  # In case, for example, the file has been deleted and doesn't exist in current [index]
  path_for_git_show = path
end

if @save
  extension = Pathname.new(path).extname    # Retain the extension so that editors (vim), etc. that look at the extension for syntax highlighting, etc. won't be confused
  if @name_only
    save_as = @save_as || path
  else
    save_as = @save_as || "#{path}.#{revision}#{extension}"
  end

  save_as = Pathname.new(save_as)
  if save_as.exist? && !@overwrite
    STDERR.puts "File #{save_as} already exists! Aborting. Use -f to force/override."; exit 1
  end

  command = "git show #{revision}:'#{path_for_git_show}' > '#{save_as}'"
else
  command = "git show #{revision}:'#{path_for_git_show}'"
end

puts   command unless @quiet
system command

#---------------------------------------------------------------------------------------------------
# Original bash function version:
#
#function git-cat()      { git show HEAD:$1 
#}
#function git-cat-prev() { git show HEAD~1:$1 
#}
#
#function ext () { echo ${1##*.} ; }
#function git-cat-save()      { 
#  revision=${2:-HEAD}
#  saved_as="$1.$revision.$(ext $1)"
#  git show $revision:$1   > $saved_as
#  echo "Saved as $saved_as"
#}
#function git-cat-prev-save() { 
#  saved_as="$1.head-1.$(ext $1)"
#  git show HEAD~1:$1 > $saved_as
#  echo "Saved as $saved_as"
#}
