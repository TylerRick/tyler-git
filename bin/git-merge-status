#!/usr/bin/env ruby
#---------------------------------------------------------------------------------------------------
# TODO:
# show number of conflicts
# list all conflicts (and their type/severity?)
#---------------------------------------------------------------------------------------------------
require 'pathname'
require 'quality_extensions/pathname'
require 'colored'

#---------------------------------------------------------------------------------------------------
# Parse args

require 'optparse'

@options = {
  :verbose => 0,
  :show => 'revision',
}

def parse_args
  ARGV.options do |opts|
    opts.banner = <<End
Usage: #{File.basename($0)} [options]

Detects whether there is a merge, rebase, or cherry pick in progress and provides information about the merge/etc.
End

    opts.on("-v", "--verbose", "Be more verbose")                                                                       { @options[:verbose] = 1 }
    opts.on("-t", "--type", "Output only the type of merge (merge, rebase, or cherry_pick). Exit code is 1 if none.")   { @options[:show_type_only] = true }
    opts.on("-h", "--help", "Show this help message.")                                                                  { puts opts; exit }
    opts.parse!
  end
end
parse_args

#---------------------------------------------------------------------------------------------------

def exit_code
  if @merge_type
    0
  else
    1
  end
end

def handle_show_type_only
  if @options[:show_type_only]
    if @merge_type
      puts @merge_type
      exit exit_code
    else
      exit exit_code
    end
  end
end

def print_rev(label, rev)
  rev_pretty = `git name-rev --name-only --always --no-undefined #{rev}`.chomp
  puts "#{label.bold}#{rev.inspect.green} #{"(#{rev_pretty.green})" if rev != rev_pretty}"
end

def print_head
  puts
  head_rev = `git rev-parse HEAD`.chomp
  print_rev "HEAD is currently: ", head_rev
end

#---------------------------------------------------------------------------------------------------

rebase_dir = Pathname.new('.git/rebase-apply')

if rebase_dir.exist?
  @merge_type = :rebase
  handle_show_type_only

  if (file = Pathname.new('.git/rebase-apply/onto')).exist?
    upstream = file.read.chomp
    upstream = `git name-rev --name-only --always --no-undefined #{upstream}`.chomp
    @merge_type = :rebase
  end
  if (file = Pathname.new('.git/rebase-apply/orig-head')).exist?
    mine = file.read.chomp
    mine = `git name-rev --name-only --always --no-undefined #{mine}`.chomp
  end
  puts "You are rebasing #{mine.inspect.green}".bold + " onto #{upstream.inspect.green}".bold
  print_head

  puts
  
  filename = `git rebase-show-current-rev --filename`.chomp
  puts "Currently applying this commit".bold + " (#{filename.magenta}):"
  system "git rebase-show-current-rev --summary"


elsif system('git rev-parse --verify -q MERGE_HEAD >/dev/null') == false and (file = Pathname.new('.git/MERGE_MSG')).exist?
  @merge_type = :cherry_pick
  handle_show_type_only

  puts "This is a cherry pick"

  merge_msg = file.read
  puts "merge_msg=#{merge_msg.inspect}"

  print_head



elsif system('git rev-parse --verify -q MERGE_HEAD >/dev/null') == true
  @merge_type = :merge
  handle_show_type_only

  puts "This is a normal merge".bold
  print_head

  upstream   ||= 'MERGE_HEAD'
  mine       ||= 'HEAD'

  #merge_base = `git merge-base MERGE_HEAD HEAD`.chomp
  merge_base = `git merge-base #{upstream} #{mine}`.chomp
  print_rev "merge base: ", merge_base

  puts "Parent commits are:"
  print_rev "Mine   (HEAD)        ", mine
  print_rev "Theirs (MERGE_HEAD): ", upstream

else
  @merge_type = nil
  handle_show_type_only

  puts "It appears that there is no merge, rebase, or cherry pick in progress."
end

if @merge_type
  puts "Unmerged paths:"
  system 'git diff-index --name-only --cached --diff-filter=U HEAD'
end

exit exit_code

#---------------------------------------------------------------------------------------------------
