#!/usr/bin/env bash

set -euo pipefail

#════════════════════════════════════════════════════════════════════════════════════════════════════

usage() {
  cat - <<End >&2
Usage: $(basename "$0")

Copy some details from other commit

Amends the tip commit during an interactive rebase.

This simply passes control to a more specific command depending on what HEAD is. This is convenient
for use with --exec so that you can simply add the same "fix" command after every pick or merge and
it will just "do the right thing".

If HEAD is a merge commit, this executes git-rebase-i-amend-merge-add-details.

Otherwise, this executes git-commit-amend-copy.

Example:
  git rebase -i --exec 'git-commit-amend-head'

See also: git-rebase-i-amend-merge-add-details, git-commit-amend-copy
End
  exit 64 # EX_USAGE
}

#════════════════════════════════════════════════════════════════════════════════════════════════════
# Parse args and apply defaults

while [[ $# -gt 0 ]]; do
  case "$1" in
    --help | -h)      usage;;
    -*)               echo "Unknown option $1" >&2; exit 1 ;;
    *) break ;;
  esac
done

if [ -z "${1-}" ] && [ -d .git/rebase-merge ]; then
  source_commit_input=$(git-rebase-i-get-orig-commit)
else
  source_commit_input=${1-}
fi

#════════════════════════════════════════════════════════════════════════════════════════════════════

source_commit=$(git rev-parse --verify "$source_commit_input"^{commit})
source_short=$(git rev-parse --short $source_commit)

# The commit we are amending, which can only be HEAD
head=$(git rev-parse HEAD)
head_short=$(git rev-parse --short HEAD)

#════════════════════════════════════════════════════════════════════════════════════════════════════

if git-is-merge-commit $head; then
  git-rebase-i-amend-merge-add-details
else
  git-commit-amend-copy
fi
