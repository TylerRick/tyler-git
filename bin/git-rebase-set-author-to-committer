#!/usr/bin/env ruby
# Based on git-rebase-set-commit-date-to-author-date
# Could probably make a more general command that can be used for these more specific tasks.
# Also, maybe make a version that applies to the most recent commit by default, like
# git-set-author-to-committer.

require 'facets/string/cleanlines'

def command_name
  File.basename($0)
end

def run(command)
  puts command
  system command
  unless $?.success?
    puts "Command failed. Aborting."
    exit 1
  end
end

# Based on /usr/lib/git-core/git-rebase--interactive
def rev_list_with_message(rev_range)
  command = <<-End
  git rev-list --pretty=oneline --abbrev-commit \\
    --abbrev=7 --reverse --left-right --topo-order \\
    #{rev_range} | sed -n "s/^>//p"
  End
  #puts command
  `#{command}`.cleanlines
end

def rev_from_rev_with_message(rev_with_message)
  rev_with_message.match(/^(\w+) /) && $1
end

def commit_info
  @commit_info ||= `git commit-modify --show-info-only #{@rev}`.chomp
end
def committer_name
  commit_info =~ /^GIT_COMMITTER_NAME=(.*)$/ and $1
end
def committer_email
  commit_info =~ /^GIT_COMMITTER_EMAIL=(.*)$/ and $1
end
def author_name 
  commit_info =~ /^GIT_AUTHOR_NAME=(.*)$/ and $1
end
def author_email 
  commit_info =~ /^GIT_AUTHOR_EMAIL=(.*)$/ and $1
end
def author_date 
  commit_info =~ /^GIT_AUTHOR_DATE=(.*)$/ and $1
end

def update_current_commit(rev)
  @rev = rev
  @commit_info = nil
  ENV['GIT_COMMITTER_NAME'] = nil
  ENV['GIT_COMMITTER_EMAIL'] = nil

  # Sometimes cherry-pick sets commit date to current date. Unfortunately cherry-pick doesn't have a --committer-date-is-author-date option like git rebase does.
  # We can do this to add our own "--committer-date-is-author-date" functionality:
  #system %(GIT_COMMITTER_DATE='#{author_date}' git commit-modify)
  # No we can't. Because by this point it will already have been changed.
  # So switched to git cherry-pick -n instead.
  ENV['GIT_COMMITTER_DATE']=author_date

  # set-author-to-committer
  #puts %(GIT_AUTHOR_EMAIL='#{committer_email}' git commit-modify)
  #system %(GIT_AUTHOR_EMAIL='#{committer_email}' git commit-modify)

  # Or, if you just want to set it to something hard-coded.
  # (This command needs to be made more general-purpose.)
  #system %(GIT_COMMITTER_EMAIL='tyler.rick@k3integrations.com' GIT_AUTHOR_EMAIL='tyler.rick@k3integrations.com' git commit-modify)
  # GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL seem to have no effect when using git commit
  # --reuse-message=<commit>, so we have to use --author to override the author from <commit>
  # Fortunately, GIT_COMMITTER_* seem to work.
  puts %(author: #{author_name} <#{author_email}>)
  if author_email =~ /pro7tech/ || author_name =~ /pro7tech/
    ENV['GIT_COMMITTER_NAME']='Jonathan Morris'
    ENV['GIT_COMMITTER_EMAIL']='jonathan@pro7tech.com'

    run %(git commit --reuse-message=#{rev} --author='Jonathan Morris <jonathan@pro7tech.com>')
  else
    run %(git commit --reuse-message=#{rev})
  end

  system %(git log --format=fuller -1)
end

# Based on /usr/lib/git-core/git-rebase and /usr/lib/git-core/git-rebase--interactive
def move_to_original_branch(head_name, orig_head)
  new_head = `git rev-parse HEAD`.chomp

  message = "#{command_name} finished: #{goal_text}"
  run <<-End
    git update-ref -m "#{message}" #{head_name} #{new_head} #{orig_head}
  End

  message = "#{command_name} finished: Moving back to #{head_name}"
  run <<-End
    git symbolic-ref -m "#{message}" HEAD #{head_name}
  End
end

#===================================================================================================

Dir.chdir(File.dirname(`git rev-parse --git-dir`.chomp))

onto = ARGV[0] or raise 'missing onto'
head_name=`git symbolic-ref -q HEAD`.chomp
head_name =~ %r(^refs/heads/) or raise "head_name must start with refs/heads/ but was #{head_name}"
orig_head = `git rev-parse --short HEAD`.chomp

# The list of commits *not* including onto itself.
rev_list_with_message = rev_list_with_message("#{onto}..#{orig_head}").to_a
rev_list = rev_list_with_message.map { |line| rev_from_rev_with_message(line) }
rev_list_with_message.size == rev_list.size or raise "number of lines should match"

define_method :goal_text do
  "Fixing all commits from #{onto} up to #{head_name} (#{orig_head})"
end

puts goal_text

run %(git checkout #{onto})

rev_list_with_message.each do |rev_with_message|
  rev = rev_from_rev_with_message(rev_with_message)

  #puts "Continue to cherry-pick #{rev_with_message}?"
  #$stdin.gets

  run %(git cherry-pick -n #{rev})
  update_current_commit rev
end

# For testing:
#head_name = 'refs/heads/onto'; orig_head = '1419fc5be82d014bc917fd199ca3740e8a2c399c'

move_to_original_branch(head_name, orig_head)
