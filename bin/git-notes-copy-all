#!/bin/bash

set -euo pipefail

print_usage() {
  cat - <<End >&2
Usage:
  $(basename "$0") <old-commit> <new-commit>
    - Copy notes from <old-commit> to <new-commit> for all refs under refs/notes/*

  $(basename "$0") --map-file <file>
    - Copy notes from a list of commit pairs in <file>, where each line is: <old> <new>

Options:
	--force, -f
		When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).

  --refs <glob1:glob2:...>
    - Limit refs to those matching the given colon-separated globs (like GIT_NOTES_REWRITE_REF)

  --map-file <file>
    - Read <old> <new> commit pairs from file instead of positional args
End
  exit 1
}

#════════════════════════════════════════════════════════════════════════════════════════════════════

notes_copy_opts=""
refs_globs=()
map_file=""
old_commit=""
new_commit=""

# Parse args
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --force | -f)
      notes_copy_opts='-f'
      shift
      ;;
    --refs)
      [[ $# -lt 2 ]] && print_usage
      IFS=':' read -r -a refs_globs <<< "$2"
      shift 2
      ;;
    --map-file)
      [[ $# -lt 2 ]] && print_usage
      map_file="$2"
      shift 2
      ;;
    -*)
      echo "Unknown option: $1" >&2
      print_usage
      ;;
    *)
      if [[ -n "$map_file" ]]; then
        echo "Positional arguments not allowed with --map-file" >&2
        print_usage
      fi
      if [[ -z "$old_commit" ]]; then
        old_commit="$1"
      elif [[ -z "$new_commit" ]]; then
        new_commit="$1"
      else
        echo "Too many arguments" >&2
        print_usage
      fi
      shift
      ;;
  esac
done

if [[ -n "$map_file" ]]; then
  if [[ ! -f "$map_file" ]]; then
    echo "Map file not found: $map_file" >&2
    exit 1
  fi
else
  if [[ -z "$old_commit" || -z "$new_commit" ]]; then
    print_usage
  fi
fi

#════════════════════════════════════════════════════════════════════════════════════════════════════

# Collect matching refs
all_refs=$(git for-each-ref --format='%(refname)' refs/notes/)
matching_refs=()

for ref in $all_refs; do
  if [[ "${#refs_globs[@]}" -eq 0 ]]; then
    matching_refs+=("$ref")
  else
    for glob in "${refs_globs[@]}"; do
      if [[ "$ref" == $glob ]]; then
        matching_refs+=("$ref")
        break
      fi
    done
  fi
done

if [[ ${#matching_refs[@]} -eq 0 ]]; then
  echo "No matching refs found under refs/notes/*"
  exit 0
fi

# Copy and report notes
copy_notes() {
  local old="$1"
  local new="$2"
  local old_short new_short
  old_short=$(git rev-parse --short "$old")
  new_short=$(git rev-parse --short "$new")

  local any_copied=false

  for ref in "${matching_refs[@]}"; do
    if git notes --ref="$ref" show "$old" > /dev/null 2>&1; then
      # TODO: use merge instead of copy and allow passing merge strategy
      # Silence Overwriting existing notes for object errors when using -f
      git notes --ref="$ref" copy "${notes_copy_opts-}" "$old" "$new" 2>/dev/null

      if [[ "$any_copied" = false ]]; then
        echo "📤 Copied notes from commit $old_short -→ $new_short:"
        any_copied=true
      fi

      note=$(git notes --ref="$ref" show "$new" 2>/dev/null || true)

      if [[ "$note" == *$'\n'* ]] || [[ "$note" != "$(echo "$note" | tr -d '\n')" ]]; then
        echo "─── $ref ───"
        echo "$note"
        echo
      else
        echo "  • $ref: $note"
      fi
    fi
  done

  if [[ "$any_copied" = false ]]; then
    echo "ℹ️  No notes found to copy for commit $old_short"
  fi
}

if [[ -n "$map_file" ]]; then
  while read -r old new; do
    [[ -z "$old" || -z "$new" ]] && continue
    copy_notes "$old" "$new"
  done < "$map_file"
else
  copy_notes "$old_commit" "$new_commit"
fi

