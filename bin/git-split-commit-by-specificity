#!/usr/bin/env bash
#
# Split your current HEAD commit into COMMON then SPECIFIC parts,
# with “resume” support via .git/split-commit.
#
# Usage:
#   git-split-commit-by-specificity [<commit>]      # start a new split on <commit> (defaults HEAD)
#   git-split-commit-by-specificity --continue      # resume an in-progress split
#
set -euo pipefail
cd "$(git rev-parse --git-dir)/.."

# ────────────────────────────────────────────────────────────────────────────────
# 1. parse args & state
# ────────────────────────────────────────────────────────────────────────────────
state_dir=".git/split-commit"
cont=false

if [[ "${1:-}" == "--continue" ]]; then
  cont=true
  shift
fi

if $cont; then
  if [[ ! -d $state_dir ]]; then
    echo "⚠️  No split in progress. Nothing to continue." >&2
    exit 1
  fi
  commit_input=$(< "$state_dir/commit")
else
  # starting fresh
  commit_input=${1:-HEAD}
  if [[ -e $state_dir ]]; then
    echo "⚠️  A split is already in progress. Use --continue to resume." >&2
    exit 1
  fi
  mkdir -p "$state_dir"
  echo "$commit_input" > "$state_dir/commit"
fi

# resolve the commit
commit=$(git rev-parse --verify "$commit_input")

# if not resuming, ensure HEAD is pointing at it
if ! $cont; then
  head_rev=$(git rev-parse --verify HEAD)
  if [[ $head_rev != $commit ]]; then
    echo "Error: HEAD ($head_rev) must equal target commit ($commit) to start a split." >&2
    exit 1
  fi
fi

# helper for marking steps done
mark_done() { touch "$state_dir/$1"; }
is_done()  { [[ -f "$state_dir/$1" ]]; }

# ────────────────────────────────────────────────────────────────────────────────
# 2. RESET & UNSTAGE  (once)
# ────────────────────────────────────────────────────────────────────────────────
if ! is_done reset; then
  echo "→ Resetting to parent of $commit (keeping worktree)…"
  git reset --soft "${commit}^"
  git reset HEAD .
  mark_done reset
else
  echo "↪️  reset already done, skipping"
fi

# ────────────────────────────────────────────────────────────────────────────────
# 3. STAGE + COMMIT COMMON  (once)
# ────────────────────────────────────────────────────────────────────────────────
if ! is_done commit_common; then
  echo
  echo "→ Staging COMMON files…"
  mapfile -t common_files < <(
    git-ls-files-by-specificity --name-only "$commit" common
  )
  if (( ${#common_files[@]} )); then
    printf "  %s\n" "${common_files[@]}"
    git add -- "${common_files[@]}"
  else
    echo "  (none)"
  fi

  echo
  git status --short
  read -rp "Press ENTER to commit COMMON changes (reuse original message)… " _
  git commit -c "$commit"
  mark_done commit_common
else
  echo "↪️  COMMON commit already done, skipping"
fi

# ────────────────────────────────────────────────────────────────────────────────
# 4. RESTORE ORIGINAL TREE INTO WORKTREE  (once)
# ────────────────────────────────────────────────────────────────────────────────
if ! is_done restore_tree; then
  echo
  echo "→ Restoring original tree ($commit) into working copy…"
  git restore --source="$commit" --worktree .
  mark_done restore_tree
else
  echo "↪️  restore already done, skipping"
fi

# ────────────────────────────────────────────────────────────────────────────────
# 5. REVIEW + STAGE SPECIFIC  (once)
# ────────────────────────────────────────────────────────────────────────────────
if ! is_done stage_specific; then
  echo
  echo "→ Staging SPECIFIC changes (tracked diffs only)…"
  # first show mixed guidance
  mapfile -t mixed_files < <(
    git-ls-files-by-specificity --name-only "$commit" mixed
  )
  if (( ${#mixed_files[@]} )); then
    echo "Mixed-files hints:"
    for f in "${mixed_files[@]}"; do
      git-detect-file-specificity "$commit" "$f"
    done
    echo
    echo "Now interactively stage mixed-file hunks:"
    for f in "${mixed_files[@]}"; do
      while true; do
        read -rp " [a]dd hunks or [e]dit '$f'? " resp
        case "$resp" in
          a|A) git add -p "$f"; break ;;
          e|E) ${VISUAL:-${EDITOR:-vi}} "$f" ;;
          *) echo "   Enter a (add) or e (edit)." ;;
        esac
      done
    done
  fi

  # now stage the rest of the tracked diffs:
  git add -u
  mark_done stage_specific
else
  echo "↪️  SPECIFIC staging already done, skipping"
fi

# ────────────────────────────────────────────────────────────────────────────────
# 6. COMMIT SPECIFIC  (once)
# ────────────────────────────────────────────────────────────────────────────────
if ! is_done commit_specific; then
  echo
  git status --short
  read -rp "Press ENTER to commit SPECIFIC changes… " _
  git commit -c "$commit"
  mark_done commit_specific
else
  echo "↪️  SPECIFIC commit already done, skipping"
fi

# ────────────────────────────────────────────────────────────────────────────────
# 7. CLEANUP
# ────────────────────────────────────────────────────────────────────────────────
echo
echo "✔ Done splitting $commit into two commits."
git log --oneline -2

# remove state only if we did both commits
if is_done commit_specific; then
  rm -rf "$state_dir"
fi
