#!/usr/bin/env bash
#
# Split your current HEAD commit into common then specific parts.
# It will reuse the same commit message for both commits by default, but it will open it in your
# editor in case you want to change either of them.

# With “resume” support via .git/split-commit.
#
# Usage:
#   git-split-commit-by-specificity
#   git-split-commit-by-specificity --continue      # resume an in-progress split
#
set -euo pipefail
cd "$(git rev-parse --git-dir)/.."

source "$(dirname $0)"/lib/colors.sh
source "$(dirname $0)"/lib/specificity.sh

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Parse args & state
#───────────────────────────────────────────────────────────────────────────────────────────────────

state_dir=".git/split-commit"
continued=false

if [[ "${1:-}" == "--continue" ]]; then
  continued=true
  shift
fi

if $continued; then
  if [[ ! -d $state_dir ]]; then
    echo >&2 "⚠️  No split in progress. Nothing to continue."
    exit 1
  fi
  commit=$(< "$state_dir/commit")
else
  # Starting a new split
  if [[ -e $state_dir ]]; then
    echo >&2 "⚠️  A split is already in progress. Run $(basename "$0") --continue to resume."
    exit 1
  fi
  mkdir -p "$state_dir"
  # Record the original commit that we are splitting
  commit=$(git rev-parse --verify HEAD)
  echo $commit > "$state_dir/commit"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Helpers
#───────────────────────────────────────────────────────────────────────────────────────────────────

get_files_with_specificity() {
  git-diff-tree-specificity --quiet --name-only $commit $1
}

edit_file() {
  ${VISUAL:-${EDITOR:-vi}} "$@" </dev/tty >/dev/tty 2>/dev/tty
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

local_exclude_backup_file=.git/info/exclude.backup.git-split-commit-by-specificity
function disable_local_exclude_file() {
  if [ -f .git/info/exclude ]; then
    if [ -f $local_exclude_backup_file ]; then
      echo >&2 "Can't back up .git/info/exclude — $local_exclude_backup_file already exists!"
      exit 1
    fi
    mv --no-clobber .git/info/exclude $local_exclude_backup_file 
  fi
}
function undo_disable_local_exclude_file() {
  if [ -f $local_exclude_backup_file ]; then
    mv --no-clobber $local_exclude_backup_file .git/info/exclude || true
  fi
}

git_add() {
  # Unfortunately, overriding core.excludesFile only stops it from using the global ~/.gitignore
  # file, not the per-repo .git/info/exclude file. To ignore that, we'd have to either use git add
  # -f (but then we don't get useful error that we _want_ to see if local .gitignore happens to be
  # ignoring it), or temporarily move it out of the way.
  ignore_local_excludes="-c core.excludesFile=/dev/null"
  disable_local_exclude_file
  git add "$@"
  undo_disable_local_exclude_file
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

confirm_commit_loop() {
  specificity=$1
  while true; do
    echo "Ready to commit the staged $(colorize_specificity $specificity) changes? " _
    git status --short

    read -rp "  [d]iff staged changes, [C]ommit? " resp
    resp=${resp:-c}
    case "${resp,,}" in
      d)
        echo; echo
        git diff --find-renames --find-copies --staged
        echo; echo
        ;;
      c)
        break
        ;;
      *)
        echo "    Invalid option!"
        ;;
    esac
  done

  git commit -c $commit

  # We want the new commits to still show up with the same committer as the original commit. But by
  # default it would have recorded me as the committer.
  git-commit-amend-copy-committer $commit
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

# helper for marking steps done
mark_done() { touch "$state_dir/$1"; }
is_done()  { [[ -f "$state_dir/$1" ]]; }

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Start splitting: Reset & unstage
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=1.reset
if ! is_done $step; then
  echo "→ Resetting to parent of $commit (keeping worktree)…"
  git reset --soft "$commit^"
  git reset HEAD .
  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Stage 100%-common files
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=2.stage_common
if ! is_done $step; then
  echo
  mapfile -t files < <(get_files_with_specificity common)
  echo "→ Staging ${#files[@]} $(colorize_specificity common) files…"
  if (( ${#files[@]} )); then
    printf "  %s\n" "${files[@]}"
    git_add -- "${files[@]}"
  else
    echo "  (none)"
  fi
  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Help user to process mixed files that require manual review and splitting (partial staging) or
# editing 
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=3.stage_common_portion_of_mixed
if ! is_done $step; then
  echo
  mapfile -t files < <(get_files_with_specificity mixed)
  echo "→ Manually review these ${#files[@]} $(colorize_specificity mixed) files: stage the $(colorize_specificity common) hunks or edit to make it common…"
  if (( ${#files[@]} )); then
    for file in "${files[@]}"; do
      # Show lines/hits that our detector thinks is specific
      git-detect-file-specificity $commit "$file"

      # loop until user stages file
      while true; do
        read -rp "  [a]dd entire file, [p] add -p, or [e]dit '$file'? " resp
        case "${resp,,}" in
          a)
            git_add "$file"
            break
            ;;
          p)
            git add --intent-to-add "$file"
            git_add -p "$file"
            break
            ;;
          e)
            edit_file "$file"
            ;;
          *)
            echo "    Invalid option!"
            ;;
        esac
      done
    done

  else
    echo "  (none)"
  fi
  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Commit common changes, which should all be staged now
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=4.commit_common
if ! is_done $step; then
  echo

  confirm_commit_loop common

  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Restore original tree into worktree
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=5.restore_tree_with_specific
if ! is_done $step; then
  echo
  echo "→ 5. Restoring original tree ($commit) into work tree, which should contain the $(colorize_specificity specific) changes…"

  # The remaining changes from the original commit that _weren't_ included in the common commit
  # should be all the specific changes. (original_commit - common_changes = specific_changes)
  # So, restore the original commit’s tree into the work tree. The index remains at the new common
  # commit (so diff HEAD→WT = specific hunks).
  git restore --source=$commit --worktree .

  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Stage specific
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=6.stage_specific
if ! is_done $step ; then
  echo
  echo "→ 6. Staging $(colorize_specificity specific) changes…"

  git add --update

  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Commit specific
#───────────────────────────────────────────────────────────────────────────────────────────────────
step=7.commit_specific
if ! is_done $step; then
  echo

  confirm_commit_loop specific

  mark_done $step
else
  echo "↪️  $step already done: skipping"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Clean up
#───────────────────────────────────────────────────────────────────────────────────────────────────
echo
echo "✔ Done splitting $commit into two commits."
git log-oneline -2

undo_disable_local_exclude_file

rm -rf "$state_dir"
