#!/usr/bin/env bash
#
# Split your current HEAD commit into common then specific parts.
# It will reuse the same commit message for both commits by default, but it will open it in your
# editor in case you want to change either of them.

# With “resume” support via .git/split-commit.
#
# Usage:
#   git-split-commit-by-specificity
#   git-split-commit-by-specificity --continue      # resume an in-progress split

# To do:
# - add a trap that detects error and tells user to run --continue to re-try
# - add an --abort command

set -euo pipefail
cd "$(git rev-parse --git-dir)/.."

source "$(dirname $0)"/lib/colors.sh
source "$(dirname $0)"/lib/specificity.sh

#════════════════════════════════════════════════════════════════════════════════════════════════════

usage() {
  cat - <<End >&2
Usage:
  $(basename "$0")
  $(basename "$0") --continue      # resume an in-progress split

If this commit was classified as "mixed", and it is the current HEAD, then attempt to split it
into a separate common and specific commit.

(In case its specificity has not been classified yet, this will first call
git-detect-commit-specificity --trust-recorded so we will know if it is mixed or not.)

This can be used as part of an overall "split out a common repo" workflow.

Options:
  --no-copy-committer
    By default, we will call git-commit-amend-copy-committer to avoid changing the committer from
    what it was in the original commit.
End
  exit
}

#═══════════════════════════════════════════════════════════════════════════════════════════════════

continued=false
copy_committer=true
while [[ $# -gt 0 ]]; do
  case "$1" in
    --help | -h)         usage ;;
    --continue)          continued=true; shift ;;
    --no-copy-committer) copy_committer=false; shift ;;
    -*)                  echo "Unknown option $1" >&2; exit 1 ;;
    *) break ;;
  esac
done

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Parse args & mode / state
#───────────────────────────────────────────────────────────────────────────────────────────────────

state_dir=".git/split-commit"

if $continued; then
  if [[ ! -d $state_dir ]]; then
    echo >&2 "⚠️  No split in progress. Nothing to continue."
    exit 1
  fi
  commit=$(< "$state_dir/commit")
  _cyan "Continuing to split commit $commit …"
else
  # Starting a new split
  if [[ -e $state_dir ]]; then
    echo >&2 "⚠️  A split is already in progress. Run $(basename "$0") --continue to resume."
    exit 1
  fi
  mkdir -p "$state_dir"
  # Record the original commit that we are splitting
  commit=$(git rev-parse --verify HEAD)
  echo $commit > "$state_dir/commit"
fi

commit_short=$(git rev-parse --short --verify "$commit"^{commit})

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Helpers
#───────────────────────────────────────────────────────────────────────────────────────────────────

clean_up() {
  undo_disable_local_exclude_file
  rm -rf "$state_dir"
}

get_files_with_specificity() {
  git-diff-tree-specificity --quiet --name-only $commit $1
}

edit_file() {
  ${VISUAL:-${EDITOR:-vi}} "$@" </dev/tty >/dev/tty 2>/dev/tty
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

local_exclude_backup_file=.git/info/exclude.backup.git-split-commit-by-specificity
function disable_local_exclude_file() {
  if [ -f .git/info/exclude ]; then
    if [ -f $local_exclude_backup_file ]; then
      echo >&2 "Can't back up .git/info/exclude — $local_exclude_backup_file already exists!"
      exit 1
    fi
    mv --no-clobber .git/info/exclude $local_exclude_backup_file
  fi
}
function undo_disable_local_exclude_file() {
  if [ -f $local_exclude_backup_file ]; then
    mv --no-clobber $local_exclude_backup_file .git/info/exclude || true
  fi
}


git_add() {
  # Unfortunately, overriding core.excludesFile only stops it from using the global ~/.gitignore
  # file, not the per-repo .git/info/exclude file. To ignore that, we'd have to either use git add
  # -f (but then we don't get useful error that we _want_ to see if local .gitignore happens to be
  # ignoring it), or temporarily move it out of the way.
  ignore_local_excludes="-c core.excludesFile=/dev/null"
  disable_local_exclude_file
  git add "$@"
  undo_disable_local_exclude_file
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

confirm_commit_loop() {
  specificity=$1
  while true; do
    echo "Ready to commit the staged $(colorize_specificity $specificity) changes? "
    git status --short

    read -rp "  diff [s]taged changes, [C]ommit? " resp
    resp=${resp:-c}
    case "${resp,,}" in
      s)
        echo; echo
        git diff --find-renames --find-copies --staged
        echo; echo
        ;;
      c)
        break
        ;;
      *)
        echo "    Invalid option!"
        ;;
    esac
  done

  if git diff --cached --quiet; then
    echo >&2 "Nothing staged to commit! Skipping the $(colorize_specificity $specificity) commit."
  else
    git commit -c $commit

    new_commit=$(git rev-parse HEAD)
    echo $new_commit >> $state_dir/new_commits

    if $copy_committer; then
      # We want the new commits to still show up with the same committer as the original commit. But by
      # default it would have recorded me as the committer.
      git-commit-amend-copy-committer $commit
    fi

    git-set-commit-specificity @ $specificity
  fi
}

#───────────────────────────────────────────────────────────────────────────────────────────────────

# Helper for marking steps done
mark_done() { echo "done" > "$state_dir/$1"; }
is_done()  { [[ -f "$state_dir/$1" ]]; }

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Detect/get specificity
#───────────────────────────────────────────────────────────────────────────────────────────────────

#step=0.detect_specificity
#if ! is_done $step; then
#
#  mark_done $step
#else
#  echo "↪️  $step: already done"
#fi

echo
git log-oneline -1
git-detect-commit-specificity --trust-recorded $commit

recorded=$(git-get-commit-specificity HEAD)

if [ "$recorded" == mixed ] || $continued; then
  :
else
  echo "  ✅ No split needed"
  if [ -d .git/rebase-merge ] && $copy_committer; then
    # This is a convenience in case we're using this directly in a rebase, like
    #  git rebase -i --root --exec 'git-split-commit-by-specificity'
    # Otherwise, the user would have to also add git-commit-amend-copy-committer to the --exec list.
    git-commit-amend-copy-committer $(git-rebase-i-get-orig-commit)
  fi
  clean_up
  exit
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Start splitting: Reset & unstage
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=1.reset
if ! is_done $step; then
  echo "→ Resetting to parent of $commit (keeping worktree)…"
  git reset --soft "$commit^"
  git reset HEAD .
  mark_done $step
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Stage 100%-common files
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=2.stage_common
if ! is_done $step; then
  echo
  mapfile -t files < <(get_files_with_specificity common)
  echo "→ Staging ${#files[@]} $(colorize_specificity common) files…"
  if (( ${#files[@]} )); then
    printf "  %s\n" "${files[@]}"
    git_add -- "${files[@]}"
  else
    echo "  (none)"
  fi
  mark_done $step
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Help user to process mixed files that require manual review and splitting (partial staging) or
# editing
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=3.stage_common_portion_of_mixed
if ! is_done $step; then
  echo
  mapfile -t files < <(get_files_with_specificity mixed)
  echo "→ Manually review these ${#files[@]} $(colorize_specificity mixed) files: stage the $(colorize_specificity common) hunks or edit to make it common…"
  if (( ${#files[@]} )); then
    for file in "${files[@]}"; do
      # If file has already been staged (even partially staged), it means they have already taken
      # some action to stage it the way they want it. Since that is the entire purpose of the loop
      # for this file, it doesn't make sense to _ask_ them here whether they want to it, so we can
      # skip it and move on to the next unstaged file.
      if [[ $(git-staged-status "$file") =~ (fully|partly)\ staged ]]; then
        echo "${cyan}${file}:${reset} already $(git-staged-status "$file")"
        continue
      fi

      detect() {
        # Looking only at the lines that were _changed_ (could also consider _added_, but there
        # shouldn't even be any specific matches _removed_ either, so we probably want to flag that
        # too as a condition to look into),
        # Show lines/match that our detector thinks is specific to give the user hints about which
        # hunks they need to either _avoid_ staging, or edit so that they no longer match specific
        # keywords.
        tmpfile=$(mktemp)
        git add --intent-to-add "$file"
        git diff "$@" "$file" > $tmpfile
        git-detect-file-specificity --show-matches always --file $tmpfile "$file"
        [ -f "${tmpfile:-}" ] && rm -f "$tmpfile"
      }
      detect

      # Loop until user stages the file or explicitly says to do [n]othing with it.
      while true; do
        # Idea: [s]ubstitute matches with placeholder, but .git/file_specificity/specific_patterns
        # isn't in the right format for sed, and we wouldn't want to substitute for all matches
        # anyway; we'd probably want more of an interactive stepping through each match, ask what to
        # do with it, but that's a lot more work, so for now, just make them edit manually.

        file_status="  → ${cyan}${file}:${reset} $(git-staged-status "$file")"
        read -rp "$file_status: [l]og, [d]iff/[dd] detect, diff [s]taged/[sd] detect, [e]dit, [a]dd, add -[p], [n]othing? " resp
        case "${resp,,}" in
          l)
            echo; echo
            git log -n 1 --patch $commit "$file" </dev/tty >/dev/tty 2>/dev/tty
            echo; echo
            ;;
          dd)
            detect
            ;;
          sd)
            detect --staged
            ;;
          d)
            echo; echo
            git diff --find-renames --find-copies "$file" </dev/tty >/dev/tty 2>/dev/tty
            echo; echo
            ;;
          s)
            echo; echo
            git diff --find-renames --find-copies --staged "$file" </dev/tty >/dev/tty 2>/dev/tty
            echo; echo
            ;;
          e)
            edit_file "$file"
            ;;
          a)
            git_add "$file"
            break
            ;;
          p)
            git add --intent-to-add "$file"
            git_add -p "$file"
            break
            ;;
          n)
            break;
            ;;
          *)
            echo "    Invalid option!"
            ;;
        esac
      done
    done

  else
    echo "  (none)"
  fi
  mark_done $step
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Commit common changes, which should all be staged now
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=4.commit_common
if ! is_done $step; then
  echo

  confirm_commit_loop common

  mark_done $step

  git-verify-commit-common-only @ || read -p "Press Enter to continue" _
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Restore original commit tree into worktree and index (stage changes)
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=6.stage_specific_from_original_commit
if ! is_done $step ; then
  echo
  echo "→ 5. Restoring original tree ($commit), which should contain the $(colorize_specificity specific) changes, into work tree and index…"

  # The remaining changes from the original commit that _weren't_ included in the common commit
  # should be all the specific changes. (original_commit - common_changes = specific_changes)
  # So, restore the original commit’s tree into the work tree. The index remains at the new common
  # commit (so diff HEAD→WT = specific hunks).
  git restore --source=$commit --staged --worktree .

  mark_done $step
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Commit specific
#───────────────────────────────────────────────────────────────────────────────────────────────────

step=7.commit_specific
if ! is_done $step; then
  echo

  confirm_commit_loop specific

  mark_done $step
else
  echo "↪️  $step: already done"
fi

#═══════════════════════════════════════════════════════════════════════════════════════════════════
# Announce success and clean up
#───────────────────────────────────────────────────────────────────────────────────────────────────

echo
new_commits_count=$(wc -l < $state_dir/new_commits)
echo "✔ Done splitting commit $commit_short: Replaced with these ${new_commits_count} commits:"

export GIT_NOTES_DISPLAY_REF=refs/notes/specificity
git log-oneline-notes -n ${new_commits_count}
#format='%Cred%h %Cgreen%ai %Cblue%an%C(yellow)%d%Creset %s %C(magenta)%N'
#git log -2 --pretty=format:"$format"

clean_up
