#!/usr/bin/env bash

# Usage: git-detect-file-specificity [<commit>] <file>
# Detects if a file is specific via git-detect-file-is-specific.
#
# Unlike git-get-file-specificity, which _only_ reads what has previously been recorded, this
# actually tries to do some detection, and checks whether what has been recorded matches.

set -euo pipefail

source "$(dirname $0)"/lib/colors.sh
source "$(dirname $0)"/lib/specificity.sh

# commit optional
if [[ $# -eq 2 ]]; then
  commit=$1; file=$2
elif [[ $# -eq 1 ]]; then
  commit=""; file=$1
else
  echo "Usage: $(basename "$0") [<commit>] <file>" >&2
  exit 2
fi

if [[ -n "$commit" ]]; then
  # Look at file contents as of that commit
  tmpfile=$(mktemp)
  git show "$commit:$file" > $tmpfile
  file_contents=$tmpfile
else
  # Look in working tree
  if ! [ -f "$file" ]; then
    echo >&2 "$file: Does not exist"
  fi
  file_contents=$file
fi

source "$(dirname $0)"/lib/colors.sh

#════════════════════════════════════════════════════════════════════════════════════════════════════

recorded=$(git-get-file-specificity "$file")

set +e
specific_matches=$(git-detect-is-file-specific "$file_contents")
exit_code=$?
set -e
if (( $exit_code == 0 )); then
  detected_specific=true
  colorized_detected=$(colorize_specificity specific)/$(colorize_specificity mixed)
else
  detected_specific=false
  colorized_detected=$(colorize_specificity common)
fi
[ -f "${tmpfile:-}" ] && rm -f "$tmpfile"

confirm_loop() {
  local prompt="$1"; shift
  while true; do
    read -p "$(printf "${bold}%s${reset} [${cyan}s${reset}]pecific/[${cyan}m${reset}]ixed/[${cyan}c${reset}]ommon [${cyan}v${reset}]iew/[${cyan}n${reset}]o? " "$prompt")" ans
    case "${ans:-n}" in
      [sS]) echo specific; return ;;
      [mM]) echo mixed;    return ;;
      [cC]) echo common;   return ;;
      [vV]) ${VISUAL:-${EDITOR:-vi}} "$file" </dev/tty >/dev/tty 2>/dev/tty ;;
      [nN])                return ;;
      *) _yellow "Please enter a valid option." ;;
    esac
  done
}

if [[ -z "$recorded" && "$detected_specific" == true ]]; then
  echo -e "${cyan}${file}:${reset} detected=${bold}$colorized_detected${reset} but no specificity recorded yet."
  choice=$(confirm_loop "mark as specific?")
  if [[ -n "$choice" ]]; then
    specificity=$choice
    git-set-file-specificity "$file" "$specificity"
    _green "recorded ${file} as ${bold}$(colorize_specificity $specificity)${reset}."
  fi
  exit 0
fi

discrepancy_msg="recorded=${bold}$(colorize_specificity $recorded)${reset}, but detected_specific=${bold}$colorized_detected${reset}"
if [[ "$recorded" == common && "$detected_specific" == true ]]; then
  echo "$specific_matches"
  _red "${file}: Discrepancy! ${reset}${discrepancy_msg}" >&2 
  choice=$(confirm_loop "override classification for this file? (you may need to update your detection script if it failed to detect a specific/mixed file.)")
  if [[ -n "$choice" ]]; then
    git-set-file-specificity "$file" "$choice"
    _green "updated ${file} → ${bold}${choice}${reset}."
  fi
elif [[ "$recorded" =~ ^(specific|mixed)$ ]] && [[ "$detected_specific" == false ]]; then
  _yellow "${file}: No specific keywords found${reset}: ${discrepancy_msg}" >&2 
else
  # no discrepancy; detected already agrees with recorded
  echo -e "${cyan}${file}:${reset} ${green}Agreement${reset}: recorded=${bold}$(colorize_specificity $recorded)${reset}; detected=${bold}$colorized_detected${reset}"
fi
