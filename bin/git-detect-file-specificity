#!/usr/bin/env bash

set -euo pipefail

source "$(dirname $0)"/lib/colors.sh
source "$(dirname $0)"/lib/specificity.sh

#════════════════════════════════════════════════════════════════════════════════════════════════════

usage() {
  cat - <<End >&2
Usage: $(basename "$0") [<commit>] <file>

Detects if a file is specific via git-detect-file-is-specific.

Unlike git-get-file-specificity, which _only_ reads what has previously been recorded, this
actually tries to do some detection, and checks whether what has been recorded matches.

Options:
  -q, --quiet
  -m, --show-matches (never|if_disagreement|always)
  -f, --file <file_contents>
    Use <file_contents> as the file contents to check instead of using the current contents of the
    main arg <file>.
     
End
  exit
}

# Parse options
show_matches=if_disagreement
positional_args=
while (( "$#" > 0 )); do
  case "$1" in
    -h|--help)
      usage
      ;;

    -q|--quiet)
      quiet=true
      show_matches=never
      shift
      ;;

    -m|--show-matches)
      if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
        show_matches=$2
        case "$show_matches" in
          never) ;;
          if_disagreement) ;;
          always) ;;
          *)
            echo "Error: Argument for $1 is invalid" >&2
            exit 64 # EX_USAGE
            ;;
        esac
        shift
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 64 # EX_USAGE
      fi
      shift
      ;;

    -f|--file)
      if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
        file_contents=$2
        shift
      else
        echo "Error: Argument for $1 is missing" >&2
        exit 64 # EX_USAGE
      fi
      shift
      ;;

    --)
      # Done parsing options
      shift
      break
      ;;
    -* )
      echo "Unknown option: $1" >&2
      exit 64 # EX_USAGE
      ;;
    *) # preserve positional arguments
      positional_args="$positional_args $1"
      shift
      ;;
  esac
done
eval set -- "$positional_args"

# commit is optional
if (( "$#" == 2 )); then
  commit=$1
  file=$2
elif (( "$#" == 1 )); then
  # TODO: add --staged option to use index
  commit="" # blank means to use worktree
  file=$1
else
  usage
fi

if [[ -n "$commit" ]]; then
  if [ -n "${file_contents-}" ]; then
    echo "Incompatible options: Can't pass both a commit and --file" >&2
    exit 64 # EX_USAGE
  fi
  # Look at file contents as of that commit
  tmpfile=$(mktemp)
  git show "$commit:$file" > $tmpfile
  file_contents=$tmpfile
else
  # Look in working tree
  if ! [ -f "$file" ]; then
    echo >&2 "$file: Does not exist"
  fi
  if [ -z "${file_contents-}" ]; then
    file_contents=$file
  fi
fi

#════════════════════════════════════════════════════════════════════════════════════════════════════

recorded=$(git-get-file-specificity "$file")

set +e
specific_matches=$(git-detect-is-file-specific "$file_contents")
#echo "<$specific_matches>"
exit_code=$?
set -e
if (( $exit_code == 0 )); then
  detected_specific=true
  colorized_detected=$(colorize_specificity specific)/$(colorize_specificity mixed)
elif (( $exit_code == 1 )); then
  detected_specific=false
  colorized_detected=$(colorize_specificity common)
else
  exit $exit_code
fi
[ -f "${tmpfile:-}" ] && rm -f "$tmpfile"

print_matches() {
  echo "Found $(echo "$specific_matches" | sed '/^\s*$/d' | wc -l) matches:"
  if [ -n "$specific_matches" ]; then
    echo "$specific_matches"
  fi
}

confirm_loop() {
  local prompt="$1"; shift
  while true; do
    read -p "$(printf "${bold}%s${reset} [${cyan}s${reset}]pecific/[${cyan}m${reset}]ixed/[${cyan}c${reset}]ommon [${cyan}v${reset}]iew/[${cyan}n${reset}]o? " "$prompt")" ans
    case "${ans:-n}" in
      [sS]) echo specific; return ;;
      [mM]) echo mixed;    return ;;
      [cC]) echo common;   return ;;
      [vV]) ${VISUAL:-${EDITOR:-vi}} "$file" </dev/tty >/dev/tty 2>/dev/tty ;;
      [nN])                return ;;
      *) _yellow "Please enter a valid option." ;;
    esac
  done
}

if [[ -z "$recorded" && "$detected_specific" == true ]]; then
  echo -e "${cyan}${file}:${reset} detected=${bold}$colorized_detected${reset} but no specificity recorded yet."
  choice=$(confirm_loop "mark as specific?")
  if [[ -n "$choice" ]]; then
    specificity=$choice
    git-set-file-specificity "$file" "$specificity"
    _green "recorded ${file} as ${bold}$(colorize_specificity $specificity)${reset}."
  fi
  exit 0
fi

discrepancy_msg="recorded=${bold}$(colorize_specificity $recorded)${reset}, but detected=${bold}$colorized_detected${reset}"
if [[ "$recorded" == common && "$detected_specific" == true ]]; then
  if [[ $show_matches == if_disagreement || $show_matches == always ]]; then
    echo "$specific_matches"
  fi
  _red "${file}: Discrepancy! ${reset}${discrepancy_msg}" >&2 
  choice=$(confirm_loop "override classification for this file? (you may need to update your detection script if it failed to detect a specific/mixed file.)")
  if [[ -n "$choice" ]]; then
    git-set-file-specificity "$file" "$choice"
    _green "updated ${file} → ${bold}${choice}${reset}."
  fi
elif [[ "$recorded" =~ ^(specific|mixed)$ ]] && [[ "$detected_specific" == false ]]; then
  _green "${file}: No specific keywords found${reset}: ${discrepancy_msg}" >&2 
else
  # no discrepancy; detected already agrees with recorded
  if [[ $show_matches == always ]]; then
    print_matches
  fi
  echo -e "${cyan}${file}:${reset} ${green}Agreement${reset}: recorded=${bold}$(colorize_specificity $recorded)${reset}; detected=${bold}$colorized_detected${reset}"
fi
