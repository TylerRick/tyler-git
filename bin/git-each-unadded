#!/usr/bin/env ruby
#-------------------------------------------------------------------------------
# This is for *untracked* files as git add -p is for *unstaged* (but tracked) files
# It is similar to git add -i and then selecting '[a]dd untracked' but is easier and more fun to use.

#-------------------------------------------------------------------------------

require 'rubygems' 
require 'git'      # requires my changes to ruby-git, (git.status.untracked)
require 'colored'
require 'pathname'
require 'facets/blank'

begin
  gem 'termios'
  require 'termios'
  begin
    # Set up termios so that it returns immediately when you press a key.
    # (http://blog.rezra.com/articles/2005/12/05/single-character-input)
    t = Termios.tcgetattr(STDIN)
    save_terminal_attributes = t.dup
    t.lflag &= ~Termios::ICANON
    Termios.tcsetattr(STDIN, 0, t)

    # Set terminal_attributes back to how we found them...
    at_exit { Termios.tcsetattr(STDIN, 0, save_terminal_attributes) }
  rescue RuntimeError => exception    # Necessary for automated testing.
    if exception.message =~ /can't get terminal parameters/
      # :todo: Can we detect if they are piping/redirecting stdout? Don't show warning if they are simply piping stdout.
      # On the other hand, when ELSE do we expect to not find a terminal? Is this message *ever* helpful?
      # Only testing? Then maybe the tests should set an environment variable or *something* to communicate that they want non-interactive mode.
      puts 'Warning: Terminal not found.'
      $interactive = false
    else
      raise
    end
  end
  $termios_loaded = true
rescue Gem::LoadError
  $termios_loaded = false
end

#-------------------------------------------------------------------------------

@repo_root = `git-base-dir`.chomp
@cdup = `git-rev-parse --show-cdup`.chomp
def relative_to_wd(path)
  @cdup.blank? ? path : File.join(@cdup, path)
end
@git = Git.open(@repo_root)
@lines_preview_to_show = 50

begin
  show_full = true

  @git.status.untracked.each do |filename|
    path = relative_to_wd(filename)

    if show_full
      puts ('_'*80).green
      lines = `wc -l #{path}`.chomp.to_i
      if @lines_preview_to_show >= 1 and lines >= 1
        system %(head -n #{@lines_preview_to_show} #{path})
        print ''.white
        puts '...' unless !$?.success? || lines <= @lines_preview_to_show
      elsif lines == 0
        puts '[Empty file]'.cyan
      end
    else
      show_full = true
    end

    print "#{path.magenta} [a/v/i/m/r/q/?] > ".cyan

    resp = STDIN.getc.chr
    case resp

    when '?'
      puts
      puts "(a)dd; (v)iew, add to .git(i)gnore, ignore for (m)e only, (r)emove, (q)uit, ..., Enter/Space to skip"
      show_full = false
      redo

    when 'a'
      system %(git-add "#{path}")
      puts

    when 'v'
      system %(cat "#{path}")
      puts
      show_full = false
      redo

    when 'i'
      system %(git-ignore "#{path}")
      puts

    when 'm'
      system %(git-ignore-for-me "#{path}")
      puts

    when 'r'
      print "Really delete".red + " #{path.magenta}" + "?? (y)es/(n)o > ".red
      resp = STDIN.getc.chr
      system %(rm "#{path}") if resp.downcase == 'y'
      puts

    when 'q'
      raise Interrupt, ''

    when ' '
      puts
      # next
 
    when "\n"
      # next

    else
      puts
      show_full = false
      redo
    end

  end

rescue Interrupt
  puts
end

system %(git status)
