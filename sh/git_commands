#!/bin/bash

#------------------------------------------

alias grp='  git-rev-parse'
alias grpH=' git-rev-parse HEAD'
alias grpOH='git-rev-parse ORIG_HEAD'

alias git-apply-commit='git-cherry-pick' # Apply the change introduced by an existing commit

#------------------------------------------

alias    gp='git pull'
alias   gup='git update' #  [custom]

#------------------------------------------

alias    gb='git branch'
alias   gba='git branch -a -v'  # Show all branches (including remote branches) and which commit they are pointing to


alias    gd='git diff --ignore-all-space'          # staged vs. unstaged (unstaged changes are +)
alias   gdc='git diff --ignore-all-space --cached' # previous commit (cached?) vs. staged (staged changes are +)
alias    gs='git status'
alias gshow='git show'
alias   gsb='git show-branch'


#------------------------------------------

alias   gst='git stash'
alias  gstl='git stash list'
alias  gsta='git stash apply'   # use pop instead
alias  gstp='git stash pop'
alias  gsts='git stash show'    # shows stat lines (which files changed)
alias gstsp='git stash show -p' # shows actual patch/diff for that stash

alias gsta1='git stash apply stash@{1}'
alias gsta2='git stash apply stash@{2}'
alias gsts1='git stash show stash@{1}'
alias gsts2='git stash show stash@{2}'
alias gstsp1='git stash show -p stash@{1}'
alias gstsp2='git stash show -p stash@{2}'

#------------------------------------------

alias    gl='git log'
alias   glp='git log --patch-with-stat'                 # See the actual lines that changed
alias   gllast='git log --patch-with-stat -n1'          # What is the last thing to be committed? (probably by you)
alias   gl1='git log --pretty=oneline'
alias   gls='git log --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s"'    # git log short
alias  glcl='git log --pretty=format:"%s"'    # git log "changelog" (show only the messages)
alias   gll='git log --stat'                                                        # git log long
alias   glc='git log --date-order'                                                  # git log (reverse) chronological
alias   glh='git log --color | head -n30'       # Only show the first 30 lines of the log. Also, since this isn't paginated, it will wrap long lines for you, so this one is useful if you want to use the mouse to copy and paste the commit message of a recent commit (into an invoice, f.e.).

# do a "pickaxe" search for the expression in the code; I think git-log is smart enough to not only only include the revisions that contain the search expression but also only the actual files and hunks that include it
function git-search() { git log --patch-with-stat -S$1
}

# refs/
#git-log refs/heads/master
#git-log refs/remotes/origin/master

#------------------------------------------

function ext () { echo ${1##*.} ; }

# cat a file from a certain rev
# git-show <rev>:<path>
function git-cat()      { git-show HEAD:$1 
}
function git-cat-prev() { git-show HEAD~1:$1 
}
# keep in mind that it will page results, so long lines won't be wrapped. If you need long lines to be wrapped (so you can select the output with your mouse and know that you're not going to be getting any truncated lines, you many want to pipe to cat - or
# use git --no-pager show ...

function git-cat-save()      { 
  saved_as="$1.head.$(ext $1)"
  git-show HEAD:$1   > $saved_as
  echo "Saved as $saved_as"
}
function git-cat-prev-save() { 
  saved_as="$1.head-1.$(ext $1)"
  git-show HEAD~1:$1 > $saved_as
  echo "Saved as $saved_as"
}

#------------------------------------------
# Compare your working tree version with the HEAD version and interactively revert (copy from HEAD) changes you have made
# This shows you the same thing as git diff but it's interactive: it lets you edit the file even while you're looking at the diff!
# Useful if you overwrite your working version with a generated version (generated by the rails command, f.e.) and you want to incorporate some of the changes
# from the generated version without losing what you had before. Well, during the overwrite you *will* lose what you had before, but this command lets you 
# quickly get it back.
# Somewhat similar to git-mergetool (when using vimdiff)
function git-vimdiff()      { 
  git-cat-save $1
  vimdiff $saved_as $1
  rm $saved_as
}
alias   gvd='git-vimdiff'


#------------------------------------------
alias  glsf='git ls-files'
alias  glss='git ls-files-by-status'

alias   grl='git reflog | head -n10'
alias  glrl='git log -g HEAD'

#------------------------------------------
alias    ga='git add'
alias   gau='git add -u; git status'        # update staged with latest changes for all files that say "Changed but not updated" (can be undone with 'git reset')

# Interactive / loop-through-each - type commands
alias   gai='git add -i'        # interactive
# gap doesn't prompt you about untracked files though!
alias   gap='git add -p'        # interactive
alias   gdi='git diff-interactive'  # tyler-git
alias   geu='git each-unadded'      # tyler-git


#------------------------------------------
alias   grm='git rm'

# git "unstage"
alias   gus='git rm --cached' # git "unadd"/unstage. "remove the paths only from the index, leaving working tree files."
                                # Appears to be equivalent to git reset, except that git reset only works if it's in the cache (in a previous commit). Otherwise you'd get:
                                # fatal: Failed to resolve '...' [HEAD, for instance, if you just init'd a new repository] as a valid ref.
                                # Also, this seems to actually mark file as "deleted"???
                                # no, didn't that time...

#------------------------------------------
alias   grb='git update; git rebase master'  # don't forget to pass -i if you want interactive
alias  grbm='git update; git rebase master'
alias  grbi='git update; git rebase master -i'
alias  grbc='git rebase --continue'  # after resolving conflicts, do this to continue

#------------------------------------------
alias  gmt='git mergetool'

alias gmtm='git merge-to master'


#------------------------------------------
# Interruption managagement

alias  gwip='git add -u; git commit -m WIP; git stash' # work in progress
alias  gwipresume='git reset HEAD~1; git stash apply'   # resets [head] to the revision before your WIP commit (the actual changes from that commit should still be in your index); then apply the stash to get your working tree back to how it was
# or just git reset anything that may be staged, and simply use git stash/stash apply (simpler), and forget about my silly WIP commit (overly complicated)!


#------------------------------------------
# Resetting

# How do I unstage a file but keep my changes that I have in my working tree?? (Useful, for example, if you accidentally stage the wrong hunks using git add -p and you want to reset what's staged and stage some different hunks instead.)
#alias  grsf='git reset HEAD'         # reset a file (path), which must follow HEAD or git will think it's a ref/commitish
#alias  grsf='git reset --'          # reset a file (path), which must follow -- or git will think it's a ref/commitish
alias   grs='git reset' # (--mixed and HEAD are implied)

# git reset [-q] [<commit>] [--] <paths>...
#   The second form with paths is used to revert selected paths in the index from a given commit, without moving HEAD.
# Not sure what that means, but from my observations what it does is updates the index to match HEAD while keeping the modifications in the working tree -- in other words, it unstages that single file.

alias      grss='git reset --soft'
alias     grss1='git reset --soft HEAD~1'
alias    grssOH='git reset --soft ORIG_HEAD'
# don't forget that you can do gci -c ORIG_HEAD after you grss1 and make changes. That's the manual alternative to gci --amend
alias   grshard='git reset --hard'
alias  grshard1='git reset --hard HEAD~1'
alias grshardOH='git reset --hard ORIG_HEAD'


# How do I discard my changes I've made to the working tree?
# * use git checkout to replace it with the version from index
# * use git rm if you just want to get rid of it



#------------------------------------------
# Checkout

#alias gdisc='git checkout' # git "discard"
# git checkout <branch>
#       switches branches by updating the index and working tree to reflect <branch> and updating HEAD to be <branch>
# git checkout <paths>
#       updates the named paths in the working tree from the index file (i.e. it runs git-checkout-index -f -u), or from a named commit.
# So if you've staged some changes from <file> but have made other changes since then that you want to discard, git checkout <file> is safe, because it replaces file with the version that is staged (in index), not the version that is [cached] (HEAD)
alias   gco='git checkout'
alias  gcom='git checkout master'
alias gcomerge='git checkout -m'
# To check out a file from an older revision...
#   gco d72a254c39b01eec17a35f42c59fb0a2bc8eab0e app/models/user.rb

alias  gcob='git checkout -b'          # Create and check out a new branch
alias  gcot='git checkout --track -b'  # Create and check out a new branch that tracks a remote branch. example: gcot stable origin/stable'


# why doesn't co recognize the filename when I use symbolic ref but it does when I use sha (I was in master, and the file in question was untracked wrt master, but was committed in adoption branch)
#> gco heads/adoption -- config/initializers/time_extensions.rb 
#error: pathspec 'config/initializers/time_extensions.rb' did not match any file(s) known to git.
#
#> gco 5093bec -- config/initializers/time_extensions.rb




#------------------------------------------
# How do I undelete a file I've git rm'ed?
# git reset -- <file>; git checkout <file> ?
# git restore

alias   gci='git commit -v'
alias  gcia='git commit --amend'
alias  gciA='git commit -a -v'   # (can't be used with paths, but that's not a problem because you don't need the -a flag when you specify paths -- git-commit will automatically add/stage any unstaged changes made to those paths)
alias  gcq='git commit -m "."'  # if you're just working on a personal repository that doesn't matter too much, we might let you get by with being lazy and not specifying a commit message...
alias  gcqpu='git commit -m "."; git push origin master'      # even lazier still
alias gcapu='git commit -a -m "."; git push origin master'  # can't get any lazier than this
alias gcapud='git commit -a -m "."; git push origin master; cap staging deploy'  # can't get any lazier than this

alias   gpm='git push origin master'

alias gbs='git bisect'


#------------------------------------------

