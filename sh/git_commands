#!/bin/bash
# See also: ~/.gitconfig, /home/tyler/installed/tyler-git/bin

# TODO: use https://github.com/mikegerwitz/git-shortmaps to define short maps, and then change my
# aliases to use longer names

# TODO: move these aliases to .gitconfig

# meld .


#------------------------------------------
# See https://github.com/github/hub
#     https://github.com/github/hub/releases

if which hub >/dev/null; then
  #alias git=hub
  : # completion for custom git aliases semes to break with this alias?
fi

# https://raw.githubusercontent.com/github/hub/master/etc/hub.bash_completion.sh
if [ -f ~/installed/command-line/bash/hub.bash_completion.sh ]; then
  .     ~/installed/command-line/bash/hub.bash_completion.sh
fi

#------------------------------------------

alias git-apply-commit='git cherry-pick' # Apply the change introduced by an existing commit
alias gch='git cherry-pick' # Apply the change introduced by an existing commit
# TODO: how to apply changes from commit to only certain files and without committing

#------------------------------------------

alias    gf='git fetch'
alias   gfv='git fetch --verbose --prune'
alias gpull='git pull'
# Idea: git fetch and then ask if they want to rebase or do normal merge?
alias  gprb='git pull --rebase'
# git pull using merge is fine if you do all your work in your own local development branches or if you don't mind (unnecessary and easily avoidable) merge commits, but I prefer doing a fetch/rebase instead to avoid the unnecessary merge commit:
# git pull --rebase

#alias gfrb='git checkout main; gwip; git fetch; git rebase origin/main; grss1'
# Not needed now that git has autostash
#alias gfrb='git stash; git checkout main; git fetch; git rebase origin/main; git stash pop'

alias   gup='git update' #  [custom]

#------------------------------------------
# Branches

alias  gcob='git checkout -b'          # Create and check out a new branch
alias  gcot='git checkout --track -b'  # Create and check out a new branch that tracks a remote branch. example: gcot stable origin/stable'

alias    gb='git branch'
alias   gbs='git branches'
alias   gbw='git branch-wrapper'
alias   gbm='git branch-menu'
alias   gbv='git branch -v'    # Show all branches and which commit they are pointing to
#alias   gbv='git branch -v ?'    # Show all branches (including remote branches) and which commit they are pointing to
alias  gbrm='git branch-rm' # remove

function git-branch-list-plain() {
  git branch --color=never | cut -c 3-
}
#function git-delete-all-deletable-branches() {
#  git remote prune origin
#  # If it's not merged in yet, it will refuse to delete it.
#  for b in $(git-branch-list-plain); do
#    git branch -rd $b
#  done
#}

# https://stackoverflow.com/questions/20106712/what-are-the-differences-between-git-remote-prune-git-prune-git-fetch-prune
# https://stevenharman.net/git-clean-delete-already-merged-branches
# https://stackoverflow.com/questions/6127328/how-can-i-delete-all-git-branches-which-have-been-merged
# [alias]
#    cleanup = "!git branch --merged | grep  -v '\\*\\|main\\|develop' | xargs -n 1 git branch -d"
function git-delete-all-deletable-branches() {
  # Delete from refs/remotes/ (but not refs/heads/) any branches that have been deleted remotely
  git remote prune origin
  #git fetch --prune

  reference_branch=${1:-main}
  # Delete remotely any branches that have been merged into main
  for branch in $(git branch -r --merged $reference_branch --color=never | grep -v "^ .*\b$reference_branch\b"); do
    git branch -rd $branch
  done
  # Delete local branch (from refs/heads/) which may or may not even exist in remote
  for branch in $(git branch --merged $reference_branch --color=never | grep -v "^ .*\b$reference_branch\b"); do
    git branch -d $branch
  done
}


alias  gbmv='git branch-mv' # move

alias git-branch-set-merge-defaults='git config branch.main.remote origin; git config branch.main.merge refs/heads/main'


#------------------------------------------
# Diff

#alias    gd='git diff --find-renames --find-copies'                             # staged vs. unstaged (unstaged changes are +)
alias    gd='git diff-relative --find-renames --find-copies'                             # staged vs. unstaged (unstaged changes are +)
alias  gd20='git diff --find-renames --find-copies --unified=20'                # lots of context lines!
alias   gds='git diff --find-renames --find-copies --staged'                    # HEAD   vs. staged   (staged changes are +)
alias  gdis='git diff --find-renames --find-copies --ignore-all-space'          # staged vs. unstaged (unstaged changes are +)
alias gdsis='git diff --find-renames --find-copies --ignore-all-space --staged' # HEAD   vs. staged   (staged changes are +)

alias   gwd='git diff --word-diff'

# Note: if you want to show the diff for a renamed field, you have to specify both files. If you
# only specify one of them, it will just show the entire file as being new lines or removed lines.
# Example: gds -- app/views/invitations/_tr.html.haml app/views/memberships/_tr.html.haml

# --color-words
alias   gdw='git diff --find-renames --find-copies --ignore-all-space --color-words'
alias  gdws='git diff --find-renames --find-copies --ignore-all-space --color-words --staged'

# Usage: git-diff-list-files rev1 rev2
# Usage: git-diff-list-files rev
# git-diff-list-files deployed/staging/2020-04-28T23-32-10 @ | xargs bin/hot_fix_staging -r
function git-diff-list-files() {
  # https://stackoverflow.com/questions/424071/how-to-list-all-the-files-in-a-commit
  #git diff "$@" | grep 'diff --git' | nocolor | sed 's#diff --git a/##; s# b/.*##'
  git diff-tree --no-commit-id --name-only -r "$@"
}
export -f git-diff-list-files

#------------------------------------------
# Getting state/status/metadata

# would be great except that vim often leaves lines with trailing spaces on a blank line equal to current indent level:
#alias    gs='git diff --check --staged; git status'
alias    gs='git status | grep -v typechange'

alias grp='  git rev-parse'
alias grpH=' git rev-parse HEAD'
alias grpOH='git rev-parse ORIG_HEAD'

#------------------------------------------
# Getting content

alias gshow='git show'
alias   gsb='git show-branch'
# See also git-cat, git-cat-save

alias   gvd='git vimdiff'

#------------------------------------------
# Stashing

alias   gst='git stash'
alias gstsv='git stash save'    # use this if you want to specify a message, or specify -p
alias gstsvp='git stash save -p'    # use this if you want to specify a message
alias  gstl='git stash list'
alias  gsta='git stash apply'   # use pop instead
alias  gstp='git stash pop'
alias gstsh='git stash show'    # shows stat lines (which files changed)
alias gstsp='git stash show -p' # shows actual patch/diff for that stash

alias gsta1='git stash apply stash@{1}'
alias gsta2='git stash apply stash@{2}'
alias gsts1='git stash show stash@{1}'
alias gsts2='git stash show stash@{2}'
alias gstsp1='git stash show -p stash@{1}'
alias gstsp2='git stash show -p stash@{2}'

#------------------------------------------
# Show

alias   gsf='git show --pretty=fuller'

#------------------------------------------
# Log

# Refactor all to use a wrapper, which adds convenience options like --mine (--author=`git config user.name`)?

alias   glm='git log-menu'

alias    gl='git log'

# git log reverse
alias   glr='git log --color --reverse'                                             # git log (reverse) chronological order. Use glrf to specify a specific commit to start at or use -n5 instead
function  glrf() {                                                                  # git log reverse *from* a specific a commit.
  commit="$1"; shift
  # It was actually starting from the commit *after* the one you specified, so I added ^ to adjust to one commit *before* the one they wanted to start at
  git log --color --reverse $commit^...HEAD "$@"
}


# I added the -c option here because without it, it *doesn't* show me any differences *at all* for merge commits, which I find completely useless.
#man git-log says:
#       -c
#           This flag changes the way a merge commit is displayed. It shows the differences from each of the parents to the merge result simultaneously **instead of showing pairwise diff between a parent and the result one at a time**.
#           Furthermore, it lists only files which were modified from all parents.
# But I don't know how to get it to "[show] pairwise diff between a parent and the result one at a time".

#alias   glp='git log -c --color --patch-with-stat'
# TODO: figure out to use --stat=width,file_width such that it doesn't chop off filename; how do we specify percentage?; how do we get terminal's current width?
# Removed -cc from main glp because it makes it list merges even when those commits don't contain # match, when using -S search.
alias           glp='git log             --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --find-renames --find-copies'                 # See the patch/diff (the actual lines that changed)
alias glp-no-merges='git log --no-merges --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --find-renames --find-copies'                 # See the patch/diff (the actual lines that changed)
#alias    glp-follow='git log -r          --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --follow'        # This only works when a single path is given. Otherwise you get error "usage: git logs can only follow renames on one pathname at a time"
alias glp-follow-cc='git log --cc        --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --follow'        # This only works when a single path is given. Otherwise you get error "usage: git logs can only follow renames on one pathname at a time"

unalias  glp-follow 2>/dev/null
function glp-follow() {
  # diff.relative = true is great most of the time, but can be a pain sometimes.
  # For example, if you are inside of the directory where the file now lives, but it was previously
  # outside of that dir (it got moved there in a commit), then even if you have log.follow = true,
  # it won't show the history from _before_ it was moved inside of the current dir.
  # This attempts to work around that, by automatically cd'ing up to top-level, and transforming the
  # given path to absolute (relative to root) path.
  path_relative_to_top_level=$(git ls-files --full-name "$1")
  cd $(git rev-parse --show-toplevel)
  git log -r          --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --follow -- $path_relative_to_top_level
}

alias glp1='glp -1'

# Sometimes it doesn't show the diffs because the -M isn't set low enough, sou you can set it really
# low like this:
alias glpfM01='git log -c --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --follow -M01'
#alias    glp='git log -c --color -p   --numstat --no-prefix'                 # See the actual lines that changed

#alias   glpr='git log -c --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --reverse'
#function  glprf() {
#  commit="$1"; shift
#  git log --color -p --numstat --reverse $commit^...HEAD "$@"
#}
function   glprf() {
  rev=$1; shift
  # TODO: instead of putting _all_ of "$@" before revpart, only put options before the rev part, and paths at the end, after a --
  # like 4daf6e3d6..@ app/../..
  git log -c --color -p   --stat=$(echo $COLUMNS),$(expr $COLUMNS / 2) --no-prefix --reverse $rev^..HEAD "$@"
}

# Sometimes git log attempts to simplify history by omitting a commit that was later reverted and
# had no effect on the final effect. Use this if you want it to include/list *all* commits.
alias glpfullhistory='git log -p --full-history'

# Show the diff for *all* files changed by commits that changed {file}
alias glpfulldiff='git log -p --full-diff'
# TODO: add --follow if exactly 1 path passed
# otherwise we get:
# fatal: --follow requires exactly one pathspec

# Similar, but filter which files you want to see the diffs for (still only looking at commits that
# changed {file}
# glp-diff-other-files-affected-by-commits lib/report_data.rb spec/
# glp-diff-other-files-affected-by-commits --reverse lib/report_data.rb spec/
# glp-diff-other-files-affected-by-commits --reverse lib/report_data.rb -p spec/
glp-diff-other-files-affected-by-commits() {
  # This requires GNU getopt.
  # See http://stackoverflow.com/questions/402377/using-getopts-in-bash-shell-script-to-get-long-and-short-command-line-options
  opts=`getopt --options rp \
               --longoptions reverse,patch,stat,numstat \
               --name 'glp-diff-other-files-affected-by-commits' -- "$@"`
  if [ $? != 0 ] ; then return 1 ; fi

  # Note the quotes around `$TEMP': they are essential!
  echo "$@"
  eval set -- "$opts"
  echo "$@"

  lister_opts=''
  differ_opts=''
  while true; do
    case "$1" in
      -r | --reverse ) lister_opts="$lister_opts $1"; shift ;;
      -p | --patch | --stat | --numstat ) differ_opts="$differ_opts $1"; shift ;;
      -- ) shift; break ;;
      * ) break ;;
    esac
  done
  path=$1; shift;
  echo path=$path
  echo            hub log $lister_opts --follow --pretty=format:"%h" $path
  for commit in $(hub log $lister_opts --follow --pretty=format:"%h" $path); do
    echo git log -n1 $differ_opts $commit -- "$@"
         git log -n1 $differ_opts $commit -- "$@" | cat -
    echo
  done | less
}

alias gllothers='glp-diff-other-files-affected-by-commits --reverse --numstat'
alias glpothers='glp-diff-other-files-affected-by-commits --reverse --patch'


alias glpword='git log -c --color -p   --word-diff=color'        # See the changes to lines inline each on a single line, instead of showing -old +new on separate lines (like git diff --word-diff=color)

alias  glpis='git log -c --color -p   --numstat --no-prefix --ignore-all-space'
alias  glpU5='git log -c --color -U5  --numstat --no-prefix'  # Show more context in the diff/patch
alias glpU10='git log -c --color -U10 --numstat --no-prefix'
alias glpU20='git log -c --color -U20 --numstat --no-prefix'

# gll="git log --color long"
#alias   gll='git log --color --stat'
# old: I got tired of it truncating the beginnig of paths (making it impossible to copy and paste paths onto the command line, so I'm now using --numstat instead of --stat)
alias   gll='git log --color --stat --graph'
alias  glls='git log --color --stat --graph'
alias  gllf='git log --color --numstat --follow'
alias gllfM01='git log --color --numstat --follow -M01'
alias  gllr='git log --color --numstat --reverse'
function  gllrf() {
  commit="$1"; shift
  git log --color --numstat --reverse $commit^...HEAD "$@"
}

alias   gwc='git whatchanged'
alias   glfull='git log --color --format=fuller'

alias gfileschangedinsamecommitsas='gl --pretty=format:"%h" ./app/views/partials/_transfer_report.html.erb | xargs1 git log -1 --name-status {}'


alias   gllast='git log --patch-with-stat -n1'          # What is the last thing to be committed? (probably by you)

alias   gl1='git log --color --pretty=oneline'
#alias  glsnc='git log --pretty=format:"%h %ai %an - %s"'  # no color, no graph
alias  glsnc='git log --no-color --graph --pretty=format:"%h %ai %an%d %s"'  # no color, but yes graph

# git log short
# %d is like decorate, shows ref name.
# Converted these to aliases in ~/.gitconfig
#converted to log-oneline-nograph: alias  glsnograph='git log --color --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an%C(yellow)%d%Creset %s"'
alias   gls='git log-oneline-graph'
alias glsnw='git log-oneline-graph --no-walk'
#alias  glsr='git log --color         --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s" --reverse'    # git log short reverse
function gls-from-merge-base() {
  rev=$1; shift
  gls $(git merge-base $rev @)...$rev
}
function glsrf() {  # git log short reverse from
  rev=$1; shift
  git log --color --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s" --reverse "$@" $rev^..HEAD
}
# More concise variation of gls
alias  gls2nograph='git log --color --oneline --decorate'
alias  gls2='gls2nograph --graph'

function  glsh() {
  gls "$@" | head -n 20
}    # git log short | head
alias glsnp='git log --color --graph --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s" origin/main..HEAD'    # git log short not pushed

alias  glcl='git log --color --pretty=format:"%s"'    # git log "changelog" (show only the messages)
alias   glc='git log --color --date-order'                                                  # git log (reverse) chronological -- maybe not...



function    git-diff-commits() {
  # Compare metadata
  glfull -1 $1
  glfull -1 $2
  # Compare patch
  diff <(glp -1 --no-color $1) <(glp -1 --no-color $2)
  echo
  echo 'Or, only diffing addition lines:'
  diff <(glp -1 --no-color $1 | grep '^+') <(glp -1 --no-color $2 | grep '^+')
}
function git-vimdiff-commits() {
  vimdiff <(glp -1 --no-color $1) <(glp -1 --no-color $2)
}

#------------------------------------------
# Side-by-side diff instead of patch

# "git log [side-by-side] diff"
# unlike git log, which when given a single rev shows the difference introduced by that commit, with git diff/difftool, specifying a single rev makes it show the diff between that rev and the [index or working tree] (which?)
# This command/alias is here to give you something more like git log: supply a single rev and it will show the difference introduced by that commit using git difftool
function  gld() {
  rev=$1; shift
  prev_rev="$rev^"
  git difftool $prev_rev $rev "$@"
}

#------------------------------------------

function stripgitindent() {
  sed 's/^    //' | less -R
}

alias  glmine='git log --color --reverse --author="`git config user.name`"'

#------------------------------------------
# git log head

#alias   glh="glrfl HEAD~5 | sed 's/^\s*//'"      # Show the last 6 (inclusive) commits, in order, with leading whitespace stripped out
#alias   glh='git log --color | head -n30'      # Only show the first 30 lines of the log. Also, since this isn't paginated, it will wrap long lines for you, so this one is useful if you want to use the mouse to copy and paste the commit message of a recent commit (into an invoice, f.e.).

function  glh() {
  echo git log --color --pretty=format:"_____%n%Cgreen%ai%n%s%b" --reverse "$@"
  git log --color --pretty=format:"_____%n%Cgreen%ai%n%s%b" --reverse "$@" | stripgitindent | less -R
}
function  glhn() { # git log head 'n commits'
  n="${1:-5}"; shift
  #echo glrfl HEAD~${1:-5} \| sed 's/^    //' \| less -R
  glh HEAD~$n~1...HEAD "$@"
}
function  glhminen() {
  n="${1:-5}"; shift
  glhn $n --author="`git config user.name`" "$@"
}
function  glhmine() { # more general, then you can use --since=2010-01-01, etc.
  glh --author="`git config user.name`" "$@"
}

# That doesn't seem to work with --first-parent -- it still shows commits brought in by the merge (maybe the explicit revision range forces that?).
# Here's my workaround when you want to exclude commits brought in by the merge:
function  glhours() {
  commit="$1"; shift
  git log --color --reverse HEAD~${commit:-20}..HEAD --first-parent --numstat "$@" | sed 's/^\s*//' | less -R
}







#------------------------------------------

# do a "pickaxe" search for the expression in the code; I think git log is smart enough to not only only include the commits that contain the search expression but also only the actual files and hunks that include it
function git-search() { git log --color --patch-with-stat -S$1
}

function git-search-message() { git show :/$1
}

# refs/
#git log refs/heads/main
#git log refs/remotes/origin/main

alias  gH='git rev-parse       HEAD'
alias gOH='git rev-parse  ORIG_HEAD'
alias gMH='git rev-parse MERGE_HEAD'
# To browse the log of your merge head, use: glm `gMH`
# To browse the log of your merge head for a specific file, use: glm `gMH` <file>

#------------------------------------------
alias  glsf='git ls-files'
alias  glss='git ls-files-by-status'

#alias   grl='git reflog'
alias   grls='git log --pretty=oneline --abbrev-commit --walk-reflogs --color --pretty=format:"%C(yellow)%h %C(blue)%aI %C(green)%ci %Creset- %gs"'


alias   grl='git log --walk-reflogs --color '
alias  grll='git log --walk-reflogs --color --numstat'
alias grllf='git log --walk-reflogs --color --format=fuller'
alias  grlp='git log --walk-reflogs -c --color --patch-with-stat'

#alias  grlh='git reflog | head -n10'
alias  grlm='git reflog-menu'

#------------------------------------------
alias    ga='git add'

# update staged with latest changes for all files that say "Changed but not updated" (can be undone with 'git reset')
# No submodules
function gau() {
  git add -u $1
  # Don't stage the submodules, if there ary any
  if [ -n "$(gsm)" ]; then
    # the cut -c 2- strips the 1st character off, since there may be a '-', '+', or ' ' at the
    # beginning of the line, and a ' ' would mess up the 2nd cut
    submodule_names=$(gsm | cut -c 2- | cut -d' ' -f2)
    echo Unstaging submodules: $submodule_names
    git unstage $submodule_names
  fi
  git status
}
# All = With submodules
function gauall() { git add -u $1; git status; }


# Interactive / loop-through-each - type commands
alias   gai='git add -i'        # interactive
# gap doesn't prompt you about untracked files though!
alias   gap='git add -p'        # interactive
alias   gdi='git diff-interactive'  # tyler-git
alias   geu='RUBYLIB=$RUBYLIB:$HOME/dev/git/ruby-git/lib git each-unadded'      # tyler-git
alias  geum='git each-unmerged'      # tyler-git
alias   gec='git each-changed'      # tyler-git


#------------------------------------------
alias   grm='git rm'

alias   gus='git unstage' # tyler-git

# Cross between git stash (in that it stashes what isn't yet committed) and git bak (in that it
# creates a regular backup tag, rather than using git stash)
alias git-bak-stash='gau; gci -m 'wip'; git bak; grss1; git unstage .'

alias git-create-local-dir="mkdir .local;  cd .local/;  git init;  git ci -m 'Initial'"

#------------------------------------------
# Upstream/Rebase

function git-upstream() {
  upstream=$(git for-each-ref --format="%(upstream:short)" $(git symbolic-ref -q HEAD))
  if [ "$upstream" == "" ]; then
    #echo 'No upstream'
    return 1  # No upstream
  else
    echo "$upstream"
  fi
}

# These didn't work. That expanded to main followed by the supplied $1, when we wanted it to expand to only the supplied $1 if there was one...
#alias   grb='git rebase    ${1:-main}'  # don't forget to pass -i if you want interactive
#alias  grbi='echo git rebase -i ${1:-main}'

# git rebase
# TODO: make --keep-empty optional (added here for now because grbi doesn't accept option args, only commit args)
alias grb='git rebase --keep-empty'
alias grbnas='git rebase --no-autosquash' # override git config rebase.autosquash true
alias    grbm='git rebase        $(git-main-branch)'
alias   grbom='git rebase origin/$(git-main-branch)'
alias   grbim='git rebase -i        $(git-main-branch)'
alias  grbiom='git rebase -i origin/$(git-main-branch)'
# I found the following function got in the way more often than it prevented me from doing something
# stupid:
#function  grb() {
#  upstream=${1:-master}
#  git branch --contains $upstream | grep $(git-current-branch) || {
#    echo -e "\033[01;31mWarning: $upstream is not an ancestor of the current branch ($(git-current-branch))"
#    echo -e "While this *might* in fact be what you want to do, if you're just trying to clean up the history in the current branch, then it is *not* what you want to do.\033[00m"
#    echo
#    echo "This usually occurs because you've already rewritten history and, specifically, you may have rewritten that commit ($upstream). If that is the case, a rewritten version of $upstream still exists in this branch, but simply has a different commit hash."
#    echo
#    echo -e "\033[00;32mHint: This is the last commit in $upstream:\033[00m"
#    echo
#    git log -1 $upstream
#    echo
#    echo -e "\033[00;32mSearch the git log of $(git-current-branch) for a commit with the same log message as (but different commit hash from) that:\033[00m"
#    echo
#    echo -e "\033[00;32mTip #2: If you find that both branches have some commits in common — just different 'versions' of those commits — then you may want to do a git rebase --interactive onto $upstream and simply remove any 'duplicate' commits from your $(git-current-branch) branch so that it doesn't try to re-apply a slightly different version of the 'same' commit that already exists in $upstream and end up causing a merge conflict. (If it really is an *identical* commit, on the other hand, it most likely will *not* cause a conflict because it will correctly detect that this commit has already bee napplied.\033[00m"
#    echo
#    echo -e "For now, this will abort with this error, because this alias was written especially for cleaning up history."
#    echo "We should make it possible to pass -f to force it to do a rebase anyway. Or ask, 'Is this what you want [y/n]?'"
#    echo
#    echo "$upstream is contained in the following branches:"
#    # Note to self: See also git-cherry
#    git branch --contains $upstream
#    return 1 # TODO: unless -f
#        }
#  # TODO: also warn if $upstream is too far back -- that is, if it points to or before a commit that has already pushed to your remote
#  #   or if it is followed by a merge commit (git rebase doesn't seem to handle merge commits very well -- though maybe I just need to pass the right args to the command)
#  shift
#  git rebase $upstream "$@"
#}

function git-is-branch-name() {
  git rev-parse --symbolic-full-name $1 | grep -q 'refs/heads'
}

# git rebase interactive
function grbi() {
  # TODO: More accurately get list of refs that were passed (ignore --options which affect $# here);
  # TODO: save options and then pass them along when we actually exec grb. In the meantime (and
  # maybe this is good enough), we just use shift and pass along all options (but we use simpler
  # 'else' case for now, which is the downside).
  onto=$1
  # Usually $1 is present, but we also allow no args to be passed (see elif git-upstream)
  if [ -n "$1" ]; then
    shift
  fi

  if [ $# == 0 ] && $(git-is-branch-name $onto); then
    echo "Rebasing onto branch $onto"
  elif [ $# == 0 ]; then # passed a ref but no options (if options, this path can't currently handle them so use simpler else path instead)
    # Allow passing as many commits as you want, and it will find the common ancestor of all of
    # them and go back to that common commit instead
    if [ -n "$onto" ]; then
      common_ancestor=$(git common-ancestor "$onto" "$@")
      commit_list=("$onto" "$@" "$common_ancestor")
    elif git-upstream; then
      # By default, rebase onto the commit that is in common with your local branch and your upstream
      # branch, in case you have diverged
      common_ancestor=$(git common-ancestor $(git-upstream) @)
      echo "Finding common ancestor between upstream ($(git-upstream)) and HEAD... $common_ancestor"
      commit_list="$common_ancestor"
    else
      common_ancestor=@
      commit_list="$common_ancestor"
    fi

    # If you've already rewritten some history/commits, and then try to rebase onto a commit from
    # *before* you rewrote that commit, it will give you this warning and exit with an error, because
    # that's probably *not* what you want to do. When you are using git rebase to rewrite the history
    # of itself (*not* basing on another branch), then rebasing onto a commit that isn't an ancestor
    # would cause you to lose commits. (TODO: Could we honor rebase.missingCommitsCheck = warn and
    # maybe give the same error?)

    # On the other hand, if you're simply rebasing onto another branch (like master after pulling down
    # commits from upstream), that is exactly what you want to do, which is why we allow that case
    # with the git-is-branch-name check above.

    # TODO: Extract and reuse git-ensure-commit-is-ancestor
    git merge-base --is-ancestor $common_ancestor HEAD || [ "$is_branch" = 1 ] || {
      echo "$common_ancestor is not an ancestor of current head. Did you mean one of these commits?"
      declare -A commit_list_uniq; for commit in "${commit_list[@]}"; do commit_list_uniq["$commit"]=1; done
      for commit in "${!commit_list_uniq[@]}"; do
        # If not ancestor of HEAD, then try to git-find-equivalent-commit
        equiv_commit=$(git-find-equivalent-commit $commit 2>/dev/null)
        if [ -n "$equiv_commit" ]; then
          echo "- Equivalent commit found for $commit:"
          git log -n 1 $equiv_commit
        else
          echo "- No equivalent commit found for $commit"
        fi
      done
      read -n1 -p "Continue rebase onto $common_ancestor anyway? [y/N] " reply >&2
      if [ "$reply" == "y" ]; then
        :
      else
        return 1
      fi
    }
    # Do we ever want the ~?
    #onto=$common_ancestor~
    onto=$common_ancestor
  else # Options were suplied, so we skip the nice checks above and simply pass everything through as $@
    :
  fi

  echo "Rebasing onto $onto"
  grb $onto -i "$@"
}

# Rebase onto your upstream
# This appears to already the default behavior of git rebase
function grbiupstream() {
  #rev=$(git-upstream)
  #grb $rev -i
  grb -i
}

alias grbiauto='grbi $(git-find-rebase-i-commands-in-commit-messages)'

function git-ensure-commit-is-ancestor() {
  commit=$1
  git merge-base --is-ancestor $commit HEAD || {
    echo >&2 -n "$commit is not an ancestor of current head. "
    if [ -n "$git_skip_ancestor_check" ]; then
      echo >&2 "Warning: Using it anyway because \$git_skip_ancestor_check is set"
      echo $commit; exit 0
    else
      echo >&2 "Did you mean one of these commits?  (Tip: skip this check by setting git_skip_ancestor_check=1)"
    fi

    # If not ancestor of HEAD, then try to git-find-equivalent-commit
    equiv_commit=$(git-find-equivalent-commit $commit 2>/dev/null)
    if [ -n "$equiv_commit" ]; then
      echo >&2 "- Equivalent commit found for $commit:"
      git log -n 1 $equiv_commit >&2
      # read -n1 -p "Use equivalent commit $equiv_commit? [Y/n] " reply >&2
    else
      echo >&2 "- No equivalent commit found for $commit"
      read -n1 -p "Use $commit anyway? [y/N] " reply >&2
      if [ "$reply" == "y" ]; then
        :
      else
        return 1
      fi
    fi
  }
  echo ${equiv_commit:-$commit}
}
export -f git-ensure-commit-is-ancestor

alias  grbi2='grbi HEAD~2'
alias  grbi3='grbi HEAD~3'
alias  grbi4='grbi HEAD~4'
alias  grbi5='grbi HEAD~5'
alias grbi10='grbi HEAD~10'
alias grbi20='grbi HEAD~20'
alias grbi30='grbi HEAD~30'
alias grbi40='grbi HEAD~40'
alias grbi50='grbi HEAD~50'

alias grb-edit-todo='git rebase --edit-todo'
alias grb-abort='git rebase --abort'
alias  grb-skip='git rebase --skip'
alias  grb-continue='git rebase --continue'  # after resolving conflicts, do this to continue
alias grbc='grb-continue'

#------------------------------------------
alias   gm='git merge'
alias gmabort='git reset --merge HEAD' #'git merge --abort'

alias  gms='git merge-status'

alias  gmt='git mergetool'
alias gmtv='git mergetool -t vimdiff'

alias gmtm='git update; git rebase master; git merge-to master'

alias  gmb='git merge-better'

# Interactively diff the next modified lile so that you can interactively choose which hunks to
# keep/merge.
# This is useful if you want to use a generator like rails app:update to force/overwrite all your
# changes with the stock upstream version but still want to be able to merge your changes back in
# afterwords. Usually generators give you the option to overwrite, skip, or view a diff, but they
# don't give any option to interactively merge the upstream version with your version (combination
# of overwrite and skip, or a hybrid somewhere in between). This function aims to add that missing
# functionality in a general way.
# Make sure all your changes are committed. Run your generator. You can just tell the generator 'a'
# to overwrite/force all files, safe in the knowledge that your version is safely stored in git. Now
# use git-diff-next-modified to see an interactive diff between your version and their (upstream)
# version. Use 'do' etc. to obtain (copy over) hunks from one side to the other.
# By the end of your editing session you should resolved all differences until the left and right
# sides are identical. (You can 'do' copy everything you want over to the Gdiff (left)
# side, and then either copy the entire contents of the left buffer over to and replace the right
# buffer or do 'git checkout file' which has the same effect.)
# If you've done that, then running git add isn't even needed. But if you made the right side your
# final state instead, then when everything is how you want it in the right side, just stage it (git
# add), so that it's no longer listed as a modified file, exit the editor, and run
# git-diff-next-modified to move on to the next file.  Or run git-diff-each-modified to automate that
# loop.
#
# Currently depends on vim and Fugitive.
function git-diff-next-modified() {
  next_modified=$(git ls-files --modified | head -n1)
  if [ -n "$next_modified" ]; then
    vim_session=~/tmp/git-diff-next-modified.vim
    cat - <<End > $vim_session
source ~/.vimrc
edit $next_modified
Gdiff
End
    vim -S $vim_session
  else
    echo "No more modified files"
    return 1
  fi
}

# Loop through each modified file, calling git-diff-next-modified
# Can exit the loop by exiting vim with :cquit instead of :quit
function git-diff-each-modified() {
  while git-diff-next-modified; do
    :
  done
}

#------------------------------------------
# Interruption managagement

#alias  gwip='git add -u; git commit -m WIP; git stash' # work in progress
#alias  gwipresume='git stash apply; git reset HEAD~1'   # resets [head] to the revision before your WIP commit (the actual changes from that commit should still be in your index); then apply the stash to get your working tree back to how it was
# or just git reset anything that may be staged, and simply use git stash/stash apply (simpler), and forget about my silly WIP commit (overly complicated)!
alias gwip='git unstage .; git stash' # ?

alias gsavesnapshot='gwip; git stash pop' # ?

# switch back to a branch that has a WIP commit, undo commit, and resume work on that feature/branch/topic
alias git-resume="TODO: git checkout {branch}; git reset HEAD~1"


#------------------------------------------
# Resetting

# If you accidentally git-add . in an svn working tree, you can use this to unadd/unstage those .svn directories:
alias gitunaddsvn='find -name .svn | xargs git reset HEAD'

# How do I unstage a file but keep my changes that I have in my working tree?? (Useful, for example, if you accidentally stage the wrong hunks using git add -p and you want to reset what's staged and stage some different hunks instead.)
#alias  grsf='git reset HEAD'         # reset a file (path), which must follow HEAD or git will think it's a ref/commitish
#alias  grsf='git reset --'          # reset a file (path), which must follow -- or git will think it's a ref/commitish
alias   grs='git reset' # (--mixed and HEAD are implied)

# git reset [-q] [<commit>] [--] <paths>...
#   The second form with paths is used to revert selected paths in the index from a given commit, without moving HEAD.
# Not sure what that means, but from my observations what it does is updates the index to match HEAD while keeping the modifications in the working tree -- in other words, it unstages that single file.

alias      grss='git reset --soft'
alias     grss1='git reset --soft HEAD~1'
alias    grssOH='git reset --soft ORIG_HEAD'
# don't forget that you can do gci -c ORIG_HEAD after you grss1 and make changes. That's the manual alternative to gci --amend
alias   grshard='git reset-hard-safe'
alias     grshm='git reset-hard-menu'
alias  grshard1='git reset-hard-safe HEAD~1'
alias grshardOH='git reset-hard-safe ORIG_HEAD'
alias      grmc='git rm --cached -r'        # For example, you notice that after you added some back directory, one of its subdirectories was a backup dir and shouldn't be added, so you want to remove the entire subdir from the cache.


# How do I discard my changes I've made to the working tree?
# * use git checkout to replace it with the version from index
# * use git rm if you just want to get rid of it



#------------------------------------------
alias git-main-branch0='if git rev-parse --quiet --verify refs/heads/main; then echo main; else echo master; fi'
# In some repos that were cloned long ago using older git version, the file
# .git/refs/remotes/origin/HEAD is missing. You can fix that with:
#   echo 'ref: refs/remotes/origin/main' > .git/refs/remotes/origin/HEAD
# or
#   git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main
# This may also work:
#   > git remote set-head origin -a
#   origin/HEAD set to main
alias git-main-branch='git rev-parse --abbrev-ref origin/HEAD | sed "s#origin/##"'
# This is much more likely to be (still) accurate, but also much slower. See https://stackoverflow.com/questions/64904364/how-can-i-ask-git-for-the-name-of-a-repositorys-default-branch
alias git-remote-main-branch='git remote show $(git remote show|tail -n1)|grep "HEAD branch"|awk '"'"'{print $NF}'"'"

#------------------------------------------
# Checkout

# git checkout <branch>
#       switches branches by updating the index and working tree to reflect <branch> and updating HEAD to be <branch>
# git checkout <paths>
#       updates the named paths in the working tree from the index file (i.e. it runs git checkout-index -f -u), or from a named commit.
# So if you've staged some changes from <file> but have made other changes since then that you want to discard, git checkout <file> is safe, because it replaces file with the version that is staged (in index), not the version that is [cached] (HEAD)
alias   gco='git checkout'
alias  gcom='git checkout $(git-main-branch)'
alias  gcoom='git checkout $(git rev-parse --abbrev-ref origin/HEAD)'
alias  gcod='git checkout develop'
alias gcomerge='git checkout -m'
# To check out a file from ("revert" a single file to) an older revision...
#   gco d72a254c39b01eec17a35f42c59fb0a2bc8eab0e app/models/user.rb

# When you have unmerged (merge conflict) files
alias gcotheirs='git checkout --theirs'
alias   gcomine='git checkout --mine'

# git "discard" -- discard changes to your working copy and index for the given file
#   In the case of a modified file: revert to (replace with) the version from HEAD
#   In the case of a new file:      delete it locally and from the index
# Why you can't just use 'git checkout file':
#   If you've already staged a file (added it to the index), then git checkout <file> will not reset it to HEAD, but to what you have staged! So you'd need to specify...
function git-discard() {
  for file in "$@"; do
    if [ "$(git ls-tree --name-only HEAD "$file")" == "" ]; then
      # File doesn't exist in HEAD, so we can't use 'git checkout HEAD'
      git rm -f $file
    else
      git checkout HEAD $file
    fi
  done
}
alias gdisc='git-discard'

# why doesn't co recognize the filename when I use symbolic ref but it does when I use sha (I was in master, and the file in question was untracked wrt master, but was committed in adoption branch)
#> gco heads/adoption -- config/initializers/time_extensions.rb
#error: pathspec 'config/initializers/time_extensions.rb' did not match any file(s) known to git.
#
#> gco 5093bec -- config/initializers/time_extensions.rb

alias   gcoh='git checkout HEAD'
alias  gcoh1='git checkout HEAD~1'
alias  gcoh2='git checkout HEAD~2'
alias  gcoh3='git checkout HEAD~3'
alias  gcoh4='git checkout HEAD~4'
alias  gcoh5='git checkout HEAD~5'
alias gcoh10='git checkout HEAD~10'
alias gcoh20='git checkout HEAD~20'


#------------------------------------------
# How do I undelete a file I've git rm'ed?
# git reset -- <file>; git checkout <file> ?
# git restore

#alias   gci='git commit -v'
# This adds the files specified (if any) before attempting the commit, because git will give an error if you try to commit a file that isn't added (in the index?) yet.
# It seemed to me that it would be more user-friendly if it simply added them (similar to how you can do git commit on files that have local/unstaged modifications and it will automatically include those unstaged changes when you do the git commit) (the difference there, I suppose, is that it didn't actually stage/add those changes, so if you abort the commit, it won't have changed anything...but I don't think that's a big problem).
function  gci() {
  # TOOD: add this back once I change it to only match files and not add whole directories recursively
  #if [ $# -ge 1 ]; then
  # git add "$@"
  #fi

  positional_args=""
  pass_through_opts=()
  while (( "$#" )); do
    case "$1" in
      -m|--message)
        if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
          pass_through_opts+=("$1" "$2")
          shift 2
        else
          echo "Error: Argument for $1 is missing" >&2
          exit 1
        fi
        ;;
      -c|--reedit-message)
        if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
          pass_through_opts+=("$1" "$2")
          shift 2
        else
          echo "Error: Argument for $1 is missing" >&2
          exit 1
        fi
        ;;
      --fixup|--squash)
        if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
          pass_through_opts+=("$1" "$2")
          shift 2
        else
          echo "Error: Argument for $1 is missing" >&2
          exit 1
        fi
        ;;
      -*|--*=) # unknown opts
        pass_through_opts+=("$1")
        shift
        ;;
      *) # preserve positional arguments
        positional_args="$positional_args $1"
        shift
        ;;
    esac
  done
  eval set -- "$positional_args"
  echo "pass_through_opts (${#pass_through_opts[@]}): ${pass_through_opts[@]}"
  #echo positional_args: "$@"

  if [ -n "$1" ]; then
    # This is so that I can use wildcards without worrying that it might match a file that's not in
    # git:
    #⟫ gci Gemfile*
    #error: pathspec 'Gemfile.lock.master.lock' did not match any file(s) known to git
    #error: pathspec 'Gemfile.master' did not match any file(s) known to git
    #echo 'Filtering out files that don't exist...'

    readarray -t files < <(git ls-files "$@")
    #echo files: "${files[@]}"
    eval set -- "${files[@]}"
  else
    # If no files were given, we can't use ls-files.
    # If partial contents of files have been staged, then we *must not* pass a list of files to git
    # commit.
    :
  fi

  set -x
  git commit "${pass_through_opts[@]}" -v "$@"
  { set +x; } 2>/dev/null
}

# Add (new file) and commit it
function  gaci() {
  git add       "$@"
  git commit -v "$@"
}

alias gcif='git commit --fixup'

# "git commit --amend" a past commit by making a temporary commit and then doing a "fixup" onto the commit you want to amend, using git rebase -i
alias gcifrb='git-commit-fixup-rebase'

# By default, git-commit will strip lines beginning with # character because it things they are commentary.
# But sometimes you want to include lines that begin with the # character. For example, if you want to include...
# * some CSS source code, which might have an #id selector
# * a ruby method definition with a comment block preceeding it (several lines of #-style comments)
# Note: you'll have to manually delete the # commentary that git-commit adds to the bottom of your commit message by default
alias gciwithhashchars='git commit --cleanup=whitespace'

alias  gcie="git commit --allow-empty-message -m ''"
alias  gcia='git commit --allow-empty --amend'   # (can be used with paths, that is, specify which paths to (only) include in the new, amended commit)
alias  gcioh='gci -c ORIG_HEAD'    # useful when you 'edit' a commit with git rebase -i, commit some of the patches as new commits, and want to commit the rest as the "original commit"
alias  gca='git commit -a -v'   # (can't be used with paths, but that's not a problem because you don't need the -a flag when you specify paths -- git commit will automatically add/stage any unstaged changes made to those paths)
alias  gcq='git commit -m "."'  # if you're just working on a personal repository that doesn't matter too much, we might let you get by with being lazy and not specifying a commit message...
alias gciq='git commit -m "."'
alias  gcqpu='git commit -m "."; git push origin main'      # even lazier still
alias gciqpu='git commit -m "."; git push origin main'
alias gacpu='git commit -a -m "."; git push origin main'  # can't get any lazier than this
alias gacpud='git commit -a -m "."; git push origin main; cap staging deploy'  # can't get any lazier than this

# TODO: create custom git push-all (gpsa) command which pushes to all remotes listed in git config push_all.remotes (or similar)
alias   gps='git push origin'
alias  gpsm='git push origin main'

alias gbs='git bisect'

#------------------------------------------
alias  gsm='git submodule'
alias gsms='git submodule status'
alias gsmi='git submodule init'
alias gsmu='git submodule update'
alias gsma='git submodule add'

# Example (the || : stops the foreach command from terminating because of a non-zero return from the shell command) : gsme 'echo hi; false || :'
alias gsme='git submodule foreach'
alias    gsmegs="git submodule foreach 'git status; echo; echo; echo'"
alias    gsmegd="git submodule foreach 'git diff;   echo; echo; echo'"
alias   gsmeglp="git submodule foreach 'git log --color -p || : ; echo; echo ; echo; echo ; echo; echo'"
alias   gsmegau="git submodule foreach 'git add -u; echo; echo; echo'"
alias   gsmegls="git submodule foreach 'git log origin/main..HEAD --color --graph --pretty=format:\"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s\"; echo; echo; echo'"
alias  gsmeglsh="git submodule foreach 'git log --color --graph --pretty=format:\"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s\" | head -n 10; echo; echo; echo'"
alias gsmegpull="git submodule foreach 'git pull || : ; echo; echo'"
alias gsmegpush="git submodule foreach 'git push || : ; echo; echo'"

# "subprojects" are subprojects that are subdir but not submodules -- they are in separate repositories than the "superproject"
# subproject-each isn't actually related to git, but I want to run all the git commands my subprojects
# The previous commands but with s/submodule foreach/subproject-foreach/g and s/gsm/gsp/ :
alias gspe='git subproject-foreach'
alias    gspegs="git subproject-foreach 'git status; echo; echo; echo'"
alias    gspegd="git subproject-foreach 'git diff;   echo; echo; echo'"
alias   gspeglp="git subproject-foreach 'git log --color -p || : ; echo; echo ; echo; echo ; echo; echo'"
alias   gspegau="git subproject-foreach 'git add -u; echo; echo; echo'"
alias   gspegls="git subproject-foreach 'git log origin/main..HEAD --color --graph --pretty=format:\"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s\"; echo; echo; echo'"
alias  gspeglsh="git subproject-foreach 'git log --color --graph --pretty=format:\"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s\" | head -n 10; echo; echo; echo'"
alias gspegpull="git subproject-foreach 'git pull || : ; echo; echo'"
alias gspegpush="git subproject-foreach 'git push origin main || : ; echo; echo'"

#------------------------------------------

