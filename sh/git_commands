#!/bin/bash

#------------------------------------------

alias git-apply-commit='git-cherry-pick' # Apply the change introduced by an existing commit
alias gcp='git-cherry-pick' # Apply the change introduced by an existing commit
# TODO: how to apply changes from commit to only certain files and without committing

#------------------------------------------

alias    gp='git pull'
alias   gup='git update' #  [custom]

#------------------------------------------
# Branches

alias  gcob='git checkout -b'          # Create and check out a new branch
alias  gcot='git checkout --track -b'  # Create and check out a new branch that tracks a remote branch. example: gcot stable origin/stable'

alias    gb='git-branch-menu'
alias   gbv='git branch -v'    # Show all branches and which commit they are pointing to
#alias   gbv='git branch -v ?'    # Show all branches (including remote branches) and which commit they are pointing to
alias  gbrm='git-branch-rm' # remove
alias  gbmv='git-branch-mv' # move

alias git-branch-set-merge-defaults='git config branch.master.remote origin; git config branch.master.merge refs/heads/master'


#------------------------------------------
# Diff

alias    gd='git diff --ignore-all-space'          # staged vs. unstaged (unstaged changes are +)
alias   gdc='git diff --ignore-all-space --cached' # previous commit (cached?) vs. staged (staged changes are +)

#------------------------------------------
# Getting state/status/metadata

alias    gs='git status'

alias grp='  git-rev-parse'
alias grpH=' git-rev-parse HEAD'
alias grpOH='git-rev-parse ORIG_HEAD'

#------------------------------------------
# Getting content

alias gshow='git show'
alias   gsb='git show-branch'
# See also git-cat, git-cat-save

alias   gvd='git-vimdiff'

#------------------------------------------
# Stashing

alias   gst='git stash'
alias  gstS='git stash save'    # use this if you want to specify a message
alias  gstl='git stash list'
alias  gsta='git stash apply'   # use pop instead
alias  gstp='git stash pop'
alias  gsts='git stash show'    # shows stat lines (which files changed)
alias gstsp='git stash show -p' # shows actual patch/diff for that stash

alias gsta1='git stash apply stash@{1}'
alias gsta2='git stash apply stash@{2}'
alias gsts1='git stash show stash@{1}'
alias gsts2='git stash show stash@{2}'
alias gstsp1='git stash show -p stash@{1}'
alias gstsp2='git stash show -p stash@{2}'

#------------------------------------------

alias    gl='git log'

#alias   glp='git log --patch-with-stat'                 # See the actual lines that changed
alias   glp='git log -p --numstat'                 # See the actual lines that changed

#alias   gll='git log --stat'                                                        # git log long
# I got tired of it truncating the beginnig of paths (making it impossible to copy and paste paths onto the command line, so I'm not using --numstat instead of --stat)
alias   gll='git log --numstat'                                                        # git log long

alias   gllast='git log --patch-with-stat -n1'          # What is the last thing to be committed? (probably by you)
alias   glh='git log --color | head -n30'       # Only show the first 30 lines of the log. Also, since this isn't paginated, it will wrap long lines for you, so this one is useful if you want to use the mouse to copy and paste the commit message of a recent commit (into an invoice, f.e.).

alias   gl1='git log --pretty=oneline'
alias   gls='git log --pretty=format:"%Cred%h %Cgreen%ai %Cblue%an %Creset- %s"'    # git log short
alias  glcl='git log --pretty=format:"%s"'    # git log "changelog" (show only the messages)
alias   glc='git log --date-order'                                                  # git log (reverse) chronological

# do a "pickaxe" search for the expression in the code; I think git-log is smart enough to not only only include the commits that contain the search expression but also only the actual files and hunks that include it
function git-search() { git log --patch-with-stat -S$1
}

# refs/
#git-log refs/heads/master
#git-log refs/remotes/origin/master

#------------------------------------------
alias  glsf='git ls-files'
alias  glss='git ls-files-by-status'

#alias   grl='git reflog | head -n10'
alias   grl='git-reflog-menu'
alias  glrl='git log -g HEAD'

#------------------------------------------
alias    ga='git add'

# update staged with latest changes for all files that say "Changed but not updated" (can be undone with 'git reset')
#function gau='git add -u; git status'
function gau() { git add -u $1; git status
}

# Interactive / loop-through-each - type commands
alias   gai='git add -i'        # interactive
# gap doesn't prompt you about untracked files though!
alias   gap='git add -p'        # interactive
alias   gdi='git diff-interactive'  # tyler-git
alias   geu='git each-unadded'      # tyler-git


#------------------------------------------
alias   grm='git rm'

alias   gus='git unstage' # [custom]

#------------------------------------------
alias   grb='git update --ask; git rebase ${1:-master}'  # don't forget to pass -i if you want interactive
alias  grbm='git update --ask; git rebase ${1:-master}'
alias  grbi='git update --ask; git rebase -i ${1:-master}'
alias grbia='git rebase -i --abort'  # abort a rebase interactive
alias  grbc='git rebase --continue'  # after resolving conflicts, do this to continue

#------------------------------------------
alias  gmt='git mergetool'

alias gmtm='git update; git rebase master; git merge-to master'


#------------------------------------------
# Interruption managagement

alias  gwip='git add -u; git commit -m WIP; git stash' # work in progress
alias  gwipresume='git reset HEAD~1; git stash apply'   # resets [head] to the revision before your WIP commit (the actual changes from that commit should still be in your index); then apply the stash to get your working tree back to how it was
# or just git reset anything that may be staged, and simply use git stash/stash apply (simpler), and forget about my silly WIP commit (overly complicated)!

# switch back to a branch that has a WIP commit, undo commit, and resume work on that feature/branch/topic
alias git-resume="TODO: git checkout {branch}; git reset HEAD~1"


#------------------------------------------
# Resetting

# If you accidentally git add . in an svn working tree, you can use this to unadd/unstage those .svn directories:
alias gitunaddsvn='find -name .svn | xargs git reset HEAD'

# How do I unstage a file but keep my changes that I have in my working tree?? (Useful, for example, if you accidentally stage the wrong hunks using git add -p and you want to reset what's staged and stage some different hunks instead.)
#alias  grsf='git reset HEAD'         # reset a file (path), which must follow HEAD or git will think it's a ref/commitish
#alias  grsf='git reset --'          # reset a file (path), which must follow -- or git will think it's a ref/commitish
alias   grs='git reset' # (--mixed and HEAD are implied)

# git reset [-q] [<commit>] [--] <paths>...
#   The second form with paths is used to revert selected paths in the index from a given commit, without moving HEAD.
# Not sure what that means, but from my observations what it does is updates the index to match HEAD while keeping the modifications in the working tree -- in other words, it unstages that single file.

alias      grss='git reset --soft'
alias     grss1='git reset --soft HEAD~1'
alias    grssOH='git reset --soft ORIG_HEAD'
# don't forget that you can do gci -c ORIG_HEAD after you grss1 and make changes. That's the manual alternative to gci --amend
alias   grshard='git-reset-hard-safe'
alias     grshm='git-reset-hard-menu'
alias  grshard1='git-reset-hard-safe HEAD~1'
alias grshardOH='git-reset-hard-safe ORIG_HEAD'


# How do I discard my changes I've made to the working tree?
# * use git checkout to replace it with the version from index
# * use git rm if you just want to get rid of it



#------------------------------------------
# Checkout

# git checkout <branch>
#       switches branches by updating the index and working tree to reflect <branch> and updating HEAD to be <branch>
# git checkout <paths>
#       updates the named paths in the working tree from the index file (i.e. it runs git-checkout-index -f -u), or from a named commit.
# So if you've staged some changes from <file> but have made other changes since then that you want to discard, git checkout <file> is safe, because it replaces file with the version that is staged (in index), not the version that is [cached] (HEAD)
alias   gco='git-checkout'
alias  gcom='git-checkout master'
alias  gcod='git-checkout dev'
alias gcomerge='git checkout -m'
# To check out a file from ("revert" a single file to) an older revision...
#   gco d72a254c39b01eec17a35f42c59fb0a2bc8eab0e app/models/user.rb

# If you've already staged a file (added it to the index), then git checkout <file> will not reset it to HEAD, but to what you have staged! So you'd need to specify...
# git "discard" -- discard changes to working copy and replace with fresh version from HEAD
alias gdisc='git checkout HEAD'

# why doesn't co recognize the filename when I use symbolic ref but it does when I use sha (I was in master, and the file in question was untracked wrt master, but was committed in adoption branch)
#> gco heads/adoption -- config/initializers/time_extensions.rb 
#error: pathspec 'config/initializers/time_extensions.rb' did not match any file(s) known to git.
#
#> gco 5093bec -- config/initializers/time_extensions.rb




#------------------------------------------
# How do I undelete a file I've git rm'ed?
# git reset -- <file>; git checkout <file> ?
# git restore

alias   gci='git commit -v'
alias  gcia='git commit --amend'
alias  gca='git commit -a -v'   # (can't be used with paths, but that's not a problem because you don't need the -a flag when you specify paths -- git-commit will automatically add/stage any unstaged changes made to those paths)
alias  gcq='git commit -m "."'  # if you're just working on a personal repository that doesn't matter too much, we might let you get by with being lazy and not specifying a commit message...
alias gciq='git commit -m "."'
alias  gcqpu='git commit -m "."; git push origin master'      # even lazier still
alias gciqpu='git commit -m "."; git push origin master'
alias gacpu='git commit -a -m "."; git push origin master'  # can't get any lazier than this
alias gacpud='git commit -a -m "."; git push origin master; cap staging deploy'  # can't get any lazier than this

alias  gpsm='git push origin master'

alias gbs='git bisect'


#------------------------------------------

